{"meta":{"title":"W4ter5heep's site","subtitle":null,"description":"Coding is fun!","author":"W4ter5heep","url":"http://www.w4ter5heep.com"},"pages":[{"title":"tags","date":"2018-04-06T01:29:00.000Z","updated":"2018-04-06T01:29:22.101Z","comments":true,"path":"tags/index.html","permalink":"http://www.w4ter5heep.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-06T01:09:53.000Z","updated":"2018-04-06T01:12:30.232Z","comments":true,"path":"categories/index.html","permalink":"http://www.w4ter5heep.com/categories/index.html","excerpt":"","text":""},{"title":"FriendLinks","date":"2018-04-06T01:48:23.000Z","updated":"2018-04-15T15:35:38.650Z","comments":true,"path":"friendlinks/index.html","permalink":"http://www.w4ter5heep.com/friendlinks/index.html","excerpt":"","text":"我我我最菜"}],"posts":[{"title":"","slug":"看雪CTF第五题——ExecuteTable","date":"2018-07-03T01:53:04.697Z","updated":"2018-07-03T01:55:52.973Z","comments":true,"path":"2018/07/03/看雪CTF第五题——ExecuteTable/","link":"","permalink":"http://www.w4ter5heep.com/2018/07/03/看雪CTF第五题——ExecuteTable/","excerpt":"","text":"看雪CTF——ExecuteTable题目确实比较有难度，自己水平还是太差了，到了so文件的分析，根本不知道关键点在哪里 初步分析首先JEB分析java部分，可以看到有一些混淆，包括对字符串的base64加密等等，但是基本逻辑是可以看到的：","categories":[],"tags":[]},{"title":"SUCTF复盘——三个RE","slug":"SUCTF复盘——三个RE","date":"2018-06-04T13:01:02.000Z","updated":"2018-07-03T01:54:47.114Z","comments":true,"path":"2018/06/04/SUCTF复盘——三个RE/","link":"","permalink":"http://www.w4ter5heep.com/2018/06/04/SUCTF复盘——三个RE/","excerpt":"","text":"RoughLike与期末大作业.Net逆向首先承认，比赛的时候因为手比较快下载的是有img文件夹的压缩包，但是很迷，上午提交截图的flag提示错误，下午就对了。。。 Alt text Alt text 更新后题目的目录结构如下： Alt text 可以发现dll文件非常大，反倒是主程序比较小在test_Data中找到比较多的文件但好像运行报错？ Alt text 还要改文件夹名字。。。 hint提示要看过场动画首先可以看到开始的过场动画： Alt text 说明flag有两段？有点牵强。。。 尝试玩了几关，没什么发现，并且动作缓慢 得到第二段flag的一种方法：查看Data文件夹中的level1文件，使用010editor直接搜索字符串，找到： Alt text 得到第二段flag：_70_5uc7F有点不讲道理 得到第一段flag方法：首先要知道Managed文件夹中Dotfuscated是因为对.NET进行了混淆：使用De4dot对Dotfuscated的Assembly-CSharp.dll进行去混淆，该工具在吾爱破解工具包中就有。然后使用.NET Reflator进行反编译，搜索关键词找到关键函数： Alt text 有两个decrypt函数： Alt text 内容： Alt text Alt text 满足这两个条件即会在地图上随机位置生成一个flag，但是条件比较苛刻：12&lt;&lt;8|12&gt;&gt;0x18目测是一个很大的数第二个也同样 可以通过修改初始参数值使条件满足，但是这里想办法分析函数：这里要查找S3cretArray数组初始化的位置是LoadBundle： Alt text 继续追踪到解密函数：DecryptAssetBundle( Alt text 前几天刚做了一个题，目测是索引表变了以后的base64 要解密的文件是： Alt text 解密脚本：12345678910111213141516171819202122import stringimport base64 custom = &quot;QRSTUVWXYZABCDEFGHIJKLMNOPabcdefghijklmnopqrstuvwxyz0123456789+/&quot;standard= &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; plainText=&quot;GetProcAddr&quot; def decryptbundle(pathname,dst): decode=&quot;&quot; with open(&quot;/Users/ilan/Desktop/SUCTF/re/Output/test_Data/StreamingAssets/bundles/%s&quot;%(pathname),&quot;rb&quot;) as f: encode=f.read() for ch in encode: if(ch in custom): decode=decode+standard[string.find(custom,str(ch))] elif(ch == &apos;=&apos;): decode= decode+&apos;=&apos; decode=base64.b64decode(decode) with open(dst,&quot;wb&quot;) as f: f.write(decode) decryptbundle(&quot;WeaponYourself.assetbundle&quot;,&quot;ext1&quot;) 此时对解密后的文件进行解析即可：利用工具解析文件，中间需要经过一步解压缩，搜索二进制文件的“flag”可以得到： Alt text 第一部分flag的base64也可以使用python的第三方库解压读取文件内容：https://github.com/HearthSim/UnityPack 在此基础上，可以通过分析代码的方式找到前半段Flag：在场景初始化函数中找到： Alt text 满足判断条件会设置为True条件为满足关卡数目和99整除且defeatedBoss数量大于0x72000000且defeatedMonster大于514时，会设置一个文本SPText标志位为true。 不可能完成的任务 因此可以直接设置SPText标志为True： Alt text 然后重新进入游戏就会直接显示flag了 官方的wp比较简单，通过修改程序执行逻辑使flag可以在程序运行时就显示flag以及相关道具 simpleformat就是一个printf输出格式化的问题程序逻辑比较简单： Alt text 需要输入36个字符，主要变换在sub_4006F6函数，然后将数据写入了/dev/null该函数比较恶心，有一大堆的dprintf Alt text 分析这一大堆奇怪的字符串，可以发现一些规律：格式基本类似于%1$*2$s，每个函数中字符串的结尾都是%20$n首先要知道参数的用法：%n指的是向任意地址写入任意值，作用是将之前输出的字符个数写入对应的参数指向的地址printf的$的用法则是指定这个格式串解析的参数偏移量。%2$s即为取出后面的第2个参数，以%s的形式输出。因此%20$n就是将之前输出的字符个数写到第20个参数的地址里。即unk_627200用于计数，因此每个dprintf最后第20个参数都是一个int数组中的元素，并且是用于memcmp的比较接下来就是每次写入的字符数量是如何获得的，分析%1$*2$s格式的含义*有指定宽度的效果，宽度取自后面的参数，%1$*2$s就是将第一个参数以第二个参数的宽度输出当输出%1$*2$s的串之后，当前输出长度即为第二个参数。继续遇到%1$*2$s则再次输出第二个参数长度，当前输出长度就变成了两倍第二个参数，最后会将输出总长度写入unk_627200因此起到了一个求和的效果：n1l1 + n2l3 + …… + n19*l19 = m1······总共18个方程，18元一次方程组大佬的脚本：123456789101112131415161718192021222324252627282930313233343536373839from zio import *from z3 import *formats = [] #数据太多太长给删掉了。。。可以自己补results = [5462280L, 4346506L, 5891159L, 6839864L, 7912833L, 7049790L, 7455784L, 7311612L, 6299256L, 7114100L, 7037043L, 6873051L, 5644794L, 8014197L, 6432215L, 6638450L, 6959905L, 6705884L]print len(formats)print len(results)s = Solver()d = [BitVec(&quot;d&#123;0&#125;&quot;.format(i), 16) for i in range(18)]for j in range(len(formats)): fmt = formats[j] left = 0 left_str = &apos;&apos; for i in range(2, 20): c = &apos;%1$*&apos;+str(i)+&apos;$s&apos; left += fmt.count(c)*d[i-2] #left_str += str(fmt.count(c))+&apos;*d[&apos;+str(i-2)+&apos;] + &apos; #print left_str s.add(left == results[j])print s.check()print s.model()model = s.model()init_state = &#123;&#125;for k in model: idx = int(str(k)[1:]) val = model[k].as_long() #print idx, val init_state[idx] = valflag = &apos;&apos;for i in range(18): flag += l16(init_state[i])print flag 注意细节，flag每两位作为了一个数伏地膜 enigma即二战时德国所使用的转轮密码机简单查看了密码机的原理，实际上enigma采用复式字母替换加密方法，利用键盘、转子、跳线、反射板、显示器进行对称加密/解密。Enigma属于算法和密钥分离的加密方法，破解Enigma的难度在于不知道当前密钥，包括转子的初始位置和跳线设置。 Alt text Alt text 查找关键函数，根据官方wp，程序实现了转轮机，线性反馈移位寄存器，换位器等输入： Alt text 长度要求是36最后经过比较要相等： Alt text 中间三个处理函数： Alt text sub_124F Alt text Alt text 单个取输入字符进行处理，然后写入最后用于比较的outstr sub_F1E Alt text Alt text sub_11F0 Alt text 因此对于输入的处理都是线性的，有爆破的可能断点下在： Alt text 然后对存储结果处的数据进行比较： Alt text Alt text 这是比较取巧的方法，需要自动调用gdb 出题人的本意是对程序进行生逆，把密文逆成明文。。。也有队伍是这么做的，服：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162with open(&apos;Enigma&apos;, &apos;rb&apos;) as f: input_enc = list(f.read()[0x30a0:][:36])def bit(a, b): return (a &gt;&gt; b) &amp; 1# sub_11F0state = 0x5F3759DFfor i in range(9): v16 = bit(state, 0) ^ bit(state, 2) ^ bit(state, 3) ^ bit(state, 5) ^ bit(state, 7) ^ bit(state, 31) state = (state &gt;&gt; 1) | (v16 &lt;&lt; 31) for j in range(4): input_enc[i*4 + j] ^= (state &gt;&gt; (j*8)) &amp; 0xff# sub_F1Edef partialRev(c): c = bin(c)[2:].rjust(8, &apos;0&apos;) c = list(map(int, c)) r = list(reversed(c)) c = r[:3] + c[3:5] + r[5:] return int(&apos;&apos;.join(map(str, c)), 2)input_enc = list(map(partialRev, input_enc))# sub_124Fwire = [ [ 0x31, 0x62, 0x93, 0xC4 ], [ 0x21, 0x42, 0x63, 0x84 ], [ 0x3D, 0x7A, 0xB7, 0xF4 ], ]def _mix(a1, a2, a3): a5 = a3 ^ a2 ^ a1 a4 = a2 &amp; a1 | a3 &amp; (a2 | a1) return (a4, a5)def mix(a2, v16, a4): bits = [] for i in range(8): v4 = bit(a2, i) v5 = bit(v16, i) a4, a5 = _mix(v5, v4, a4) bits.insert(0, a5) return int(&apos;&apos;.join(map(str, bits)), 2), a4flag = []for i, t in enumerate(input_enc): for c in range(32, 128): a4 = 0 v16 = c a2 = wire[0][i%4] v16, a4 = mix(a2, v16, a4) a2 = wire[1][(i//4%4)] v16, a4 = mix(a2, v16, a4) a2 = wire[2][i//16] v16, a4 = mix(a2, v16, a4) if v16 == t: flag.append(c) breakprint(bytes(flag).decode(&apos;ascii&apos;)) 首先获取最后结果：1234with open(&apos;Enigma&apos;, &apos;rb&apos;) as f: input_enc = list(f.read()[0x30a0:][:36])print(input_enc) 然后得到sub_11F0异或之前的结果 Alt text 该值是不是可以动态调试得到，内部有好多子函数，没有仔细分析123456state = 0x5F3759DFfor i in range(9): v16 = bit(state, 0) ^ bit(state, 2) ^ bit(state, 3) ^ bit(state, 5) ^ bit(state, 7) ^ bit(state, 31) state = (state &gt;&gt; 1) | (v16 &lt;&lt; 31) for j in range(4): input_enc[i*4 + j] ^= (state &gt;&gt; (j*8)) &amp; 0xff 然后是sub_F1E的逆向： Alt text 1234567def partialRev(c): c = bin(c)[2:].rjust(8, &apos;0&apos;) c = list(map(int, c)) r = list(reversed(c)) c = r[:3] + c[3:5] + r[5:] return int(&apos;&apos;.join(map(str, c)), 2)input_enc = list(map(partialRev, input_enc)) 也是看起来比较头疼的函数 最后是sub_124F，因为比较复杂，采用了正向python模拟实现然后爆破的方式： Alt text 没有勇气看下去。。。。12345678910111213141516171819wire = [ [ 0x31, 0x62, 0x93, 0xC4 ], [ 0x21, 0x42, 0x63, 0x84 ], [ 0x3D, 0x7A, 0xB7, 0xF4 ], ]def _mix(a1, a2, a3): a5 = a3 ^ a2 ^ a1 a4 = a2 &amp; a1 | a3 &amp; (a2 | a1) return (a4, a5)def mix(a2, v16, a4): bits = [] for i in range(8): v4 = bit(a2, i) v5 = bit(v16, i) a4, a5 = _mix(v5, v4, a4) bits.insert(0, a5) return int(&apos;&apos;.join(map(str, bits)), 2), a4","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://www.w4ter5heep.com/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.w4ter5heep.com/tags/CTF/"},{"name":"RE","slug":"RE","permalink":"http://www.w4ter5heep.com/tags/RE/"}]},{"title":"StarCTF-BabyDroid","slug":"StarCTF-BabyDroid","date":"2018-05-01T16:04:08.000Z","updated":"2018-05-01T16:30:24.660Z","comments":true,"path":"2018/05/02/StarCTF-BabyDroid/","link":"","permalink":"http://www.w4ter5heep.com/2018/05/02/StarCTF-BabyDroid/","excerpt":"","text":"逆向题目中唯一一道android逆向，做出来的过程也比较费力，这里简单记录。 安装程序发现会闪退，可能有反调试措施，首先进行静态分析。JEB查看Java代码部分： Alt text 关键方法是check0，同时注意到上面有许多check函数的native声明： Alt text 从so文件中查找相关方法。首先在liba.so中找到了check0函数：发现进一步调用的是check函数，但是在liba中没有相关信息，查找libb，没有直接找到check函数，考虑JNIOnLoad进行了注册，但是也没有找到JNIOnLoad函数，查找发现了sub_ED8函数： Alt text 对一部分数据进行了解密，同时发现了： Alt text Alt text 所以JNIOnLoad函数会在运行时才解密：解密的关键是这个值： Alt text 进入sub_9B4发现计算的应该是一个校验和，分析程序逻辑，写出计算校验和的脚本：1234567891011121314def crc32(ss): v2 = i32(-1) v7 = i32() for s in ss: if isinstance(s, bytes): s = s[0] for i in range(8): v7.value = v2.value ^ (s &gt;&gt; i &lt;&lt; 31) v2.value *= 2 if v7.value &lt;= -1: # if not 0x4C11DB7 &amp; 1: # v2.value ^= 1 v2.value ^= 0x4C11DB7 return u32(-v2.value).value - 1 得到libb的校验和：0x6674632a解密libb.so可以得到JNIOnLoad： Alt text 这里也进行了注册，将相关字符串进行解密可以发现就是对check函数的注册，解密脚本：1234567891011121314151617181920212223242526272829303132def xorstr(): def get_result(nums, key): nums = [[((i &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] for i in nums] # nums = sum(nums, []) nums = list(itertools.chain.from_iterable(nums)) nums = [i ^ key for i in itertools.takewhile(lambda i: i != 0, nums)] b = bytes(nums) return b nums = [0xBCFEFCF0, 0xEAE9A1E2, 0xF1F2F1BC, 0xF7FDF2EA, 0xF7FAFCE1, 0xFAF2DEBC, 0xE7F0D2FD, 0xE7FAE5FA, 0xea] print(get_result(nums, 0x93)) nums = [0x777C5A3E, 0x7A397760, 0x39717877, 0x7F646245, 0x3F2D7178, 0x4C] print(get_result(nums, 0x16)) nums = [0x73757873, 0x7B] print((get_result(nums, 0x10))) 解密结果为：com/q2zy/babyandroid/MainActivity (Ljava/lang/String;)Z check Alt text 即是注册的函数，但是发现依然是乱码，注意到下面还有一段解密： Alt text 这里用到了liba.so的校验和，计算发现也是0x6674632a解密得到check 函数： Alt text 再次用到了liba.so的校验和，分析逻辑写出解密脚本：1234567891011121314151617181920212223242526272829303132333435363738def get_flag(): crc = crc32(open(&apos;/Users/alset/Downloads/apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) crc2 = crc * crc checksums = [((crc2 &gt;&gt; (j * 8)) &amp; 0xff) for j in range(8)] b = bytearray([ 0xD5, 8, 0x4B, 0x11, 0xBF, 0xC, 0xB, 0x1F, 0xDC, 0x57, 0x64, 0x74, 0xB4, 0x6D, 0x5B, 0xD4, 0xEB, 0x1D, 0x51, 0xAE, 0xD5, 0x44, 8, # 0 ]) for i in range(8): for j in range(8): b[i + j] ^= checksums[j] i = 15 for j in range(8): b[i + j] ^= checksums[j] print(b) 得到flag：1nTr3stIng-AnDr0id-A&amp;D!完整解密脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import osimport mmapimport itertoolsfrom ctypes import c_int32 as i32, c_uint32 as u32def memory_map(filename, access=mmap.ACCESS_COPY): size = os.path.getsize(filename) fd = os.open(filename, os.O_RDWR) return mmap.mmap(fd, size, access=access)def crc32(ss): v2 = i32(-1) v7 = i32() for s in ss: if isinstance(s, bytes): s = s[0] for i in range(8): v7.value = v2.value ^ (s &gt;&gt; i &lt;&lt; 31) v2.value *= 2 if v7.value &lt;= -1: # if not 0x4C11DB7 &amp; 1: # v2.value ^= 1 v2.value ^= 0x4C11DB7 return u32(-v2.value).value - 1def recoverlibb(): m = memory_map(&apos;./apk/lib/armeabi-v7a/libb.so&apos;) start = 0xab8 size = 0x420 # right_asm = [0xf0, 0xb5, 0x3, 0xaf] # checksums = [m[start + i] ^ right_asm[i] for i in range(len(right_asm))] checksum = crc32(m) checksums = [((checksum &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] ichecksums = itertools.cycle(checksums) for i in range(size): m[start + i] = m[start + i] ^ next(ichecksums) start += 0x27C size -= 0x27C for i in range(0, , 4): m[start + i], m[start + i + 1], m[start + i + 2], m[start + i + 3] = m[start + i + 2], m[start + i + 3], m[ start + i], m[start + i + 1] # right_asm = [0xFF, 0xF7, 0x3E, 0xEE] # checksums = [m[start + size - 4 + i] ^ right_asm[i] for i in range(len(right_asm))] checksum = crc32(open(&apos;./apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) print(&apos;a: &apos;, checksum) checksums = [((checksum &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] ichecksums = itertools.cycle(checksums) for i in range(size): m[start + i] = m[start + i] ^ next(ichecksums) m.seek(0) open(&apos;./apk/lib/armeabi-v7a/libbnew2.so&apos;, &apos;wb&apos;).write(m.read())def xorstr(): def get_result(nums, key): nums = [[((i &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] for i in nums] # nums = sum(nums, []) nums = list(itertools.chain.from_iterable(nums)) nums = [i ^ key for i in itertools.takewhile(lambda i: i != 0, nums)] b = bytes(nums) return b nums = [0xBCFEFCF0, 0xEAE9A1E2, 0xF1F2F1BC, 0xF7FDF2EA, 0xF7FAFCE1, 0xFAF2DEBC, 0xE7F0D2FD, 0xE7FAE5FA, 0xea] print(get_result(nums, 0x93)) nums = [0x777C5A3E, 0x7A397760, 0x39717877, 0x7F646245, 0x3F2D7178, 0x4C] print(get_result(nums, 0x16)) nums = [0x73757873, 0x7B] print((get_result(nums, 0x10)))def get_flag(): crc = crc32(open(&apos;./apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) crc2 = crc * crc checksums = [((crc2 &gt;&gt; (j * 8)) &amp; 0xff) for j in range(8)] b = bytearray([ 0xD5, 8, 0x4B, 0x11, 0xBF, 0xC, 0xB, 0x1F, 0xDC, 0x57, 0x64, 0x74, 0xB4, 0x6D, 0x5B, 0xD4, 0xEB, 0x1D, 0x51, 0xAE, 0xD5, 0x44, 8, # 0 ]) for i in range(8): for j in range(8): b[i + j] ^= checksums[j] i = 15 for j in range(8): b[i + j] ^= checksums[j] print(b)if __name__ == &apos;__main__&apos;: # xorstr() # recoverlibb() get_flag()","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://www.w4ter5heep.com/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.w4ter5heep.com/tags/CTF/"},{"name":"Mobile","slug":"Mobile","permalink":"http://www.w4ter5heep.com/tags/Mobile/"}]},{"title":"HITB2018线上赛——Mobile","slug":"HITB2018线上赛——Mobile","date":"2018-04-15T15:16:39.000Z","updated":"2018-06-04T13:14:37.932Z","comments":true,"path":"2018/04/15/HITB2018线上赛——Mobile/","link":"","permalink":"http://www.w4ter5heep.com/2018/04/15/HITB2018线上赛——Mobile/","excerpt":"","text":"最近参加了HITB2018，主要做了两道Mobile，简单整理题目。 multicheck题目提示:Check！Check！Check！大概是有陷阱。 安装apk，没有多余的提示，输入flag，进行验证。首先jeb分析下java部分： 方法通过就可以了。首先看到了上面： 似乎加载了一个方法。解压apk包，找到assets中的claz.dex，赶快用jeb打开： 好像有flag，赶快手动排序得到了假的flag，提示大概是this is certainly not the flag，确实是坑。 只能继续分析so文件libcheck.soJNI_OnLoad也没有有用信息，只能挨个看sub函数找到sub_1380 注意这一段，好像进行了解密和文件的替换，byte_4004^v9并赋值到v8即是对claz.dex文件的替换。将byte_4004部分数据dump出来进行解密。保存为.dex，会发现是可以被解析的。可能就是真正的check。 这部分的调用还是稍微有些复杂的，分析了半天本来想爆破的，但是注意到了一个特殊值，即：v5 = -1640531527，查看16进制：0x9E3779B9搜索发现是Tea加密的特征值。直接从网上找可用的Tea加解密程序。过程十分曲折，找到的一些版本的程序，但是加解密结果各不相同，有点崩溃。。。终于找到一个较为标准的Java版，得到了结果。编程水平太差，只能复制粘贴，惭愧。 脚本如下：生成.dex的脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127a = [0x8D,0x8F,0x93,0xE6,0xDD,0xDD,0xDA,0xF0,0x74,0xF2,0x03,0x6D,0xC0,0xD3,0x07,0x29,0x9A,0x97,0xB7,0x3D,0xD6,0x0B,0xBC,0x53,0xF4,0x89,0x8E,0x08,0x21,0x52,0xE9,0x42,0x35,0x0D,0x0B,0x0C,0x7D,0x0E,0x0F,0x10,0x69,0x44,0x27,0x06,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x81,0x18,0x1F,0x20,0x3D,0x22,0x23,0x24,0x55,0x26,0x27,0x28,0x22,0x2A,0x2B,0x2C,0xCD,0x2E,0x2F,0x30,0x3B,0x32,0x33,0x34,0x39,0x37,0x37,0x38,0x3B,0x3A,0x3B,0x3C,0xB9,0x3F,0x3F,0x40,0x4D,0x42,0x43,0x44,0xD1,0x47,0x47,0x48,0x48,0x4A,0x4B,0x4C,0xB9,0x4F,0x4F,0x50,0x79,0x57,0x53,0x54,0x41,0x54,0x57,0x58,0x75,0x5F,0x5B,0x5C,0x6B,0x5B,0x5F,0x60,0x5F,0x67,0x63,0x64,0x24,0x63,0x67,0x68,0x24,0x6F,0x6B,0x6C,0x3D,0x6B,0x6F,0x70,0x25,0x77,0x73,0x74,0x22,0x73,0x77,0x78,0x22,0x7F,0x7B,0x7C,0x1D,0x7B,0x7F,0x80,0xE6,0x87,0x83,0x84,0xF3,0x83,0x87,0x88,0x03,0x8F,0x8B,0x8C,0x13,0x8B,0x8F,0x90,0x23,0x97,0x93,0x94,0x53,0x93,0x97,0x98,0x50,0x9F,0x9B,0x9C,0x4C,0x9B,0x9F,0xA0,0x75,0xA7,0xA3,0xA4,0x7D,0xA3,0xA7,0xA8,0x74,0xAF,0xAB,0xAC,0x4C,0xAB,0xAF,0xB0,0x54,0xB7,0xB3,0xB4,0x5D,0xB3,0xB7,0xB8,0x4A,0xBF,0xBB,0xBC,0x4B,0xBB,0xBF,0xC0,0x3C,0xC7,0xC3,0xC4,0xC0,0xC0,0xC7,0xC8,0xCB,0xCA,0xCB,0xCC,0xC9,0xCE,0xCF,0xD0,0xDB,0xD2,0xD3,0xD4,0xDE,0xD6,0xD7,0xD8,0xD5,0xDA,0xDB,0xDC,0xD0,0xDE,0xDF,0xE0,0xEF,0xE2,0xE3,0xE4,0xEA,0xE6,0xE7,0xE8,0xF8,0xEA,0xEB,0xEC,0xF9,0xEE,0xEF,0xF0,0xE4,0xF2,0xF3,0xF4,0xF0,0xF6,0xF7,0xF8,0xF8,0xFA,0xFB,0xFC,0x1D,0xFA,0xFF,0x00,0x0E,0x02,0x03,0x04,0x02,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x1D,0x0E,0x0F,0x10,0x16,0x12,0x13,0x14,0xFD,0x12,0x17,0x18,0x0B,0x1A,0x1B,0x1C,0x15,0x1E,0x1F,0x20,0xD9,0x26,0x23,0x24,0x36,0x26,0x27,0x28,0x21,0x2A,0x2B,0x2C,0x2D,0x2B,0x2F,0x30,0x37,0x32,0x33,0x34,0x3C,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3A,0x3E,0x3F,0x40,0x48,0x42,0x43,0x44,0x4D,0x43,0x47,0x48,0x40,0x4A,0x4B,0x4C,0x44,0x4E,0x4F,0x50,0x41,0x57,0x53,0x54,0x5D,0x56,0x57,0x58,0x50,0x5A,0x5B,0x5C,0x41,0x5B,0x5F,0x60,0x69,0x62,0x63,0x64,0x6F,0x66,0x67,0x68,0x4D,0x6F,0x6B,0x6C,0x6F,0x6E,0x65,0x70,0x67,0x72,0x73,0x74,0x77,0x76,0x7E,0x78,0x61,0x7A,0x7B,0x7C,0x7F,0x7E,0x7E,0x80,0x81,0x82,0x83,0x84,0x87,0x86,0x86,0x88,0x88,0x8A,0x8B,0x8C,0x8F,0x8E,0x8F,0x90,0x87,0x92,0x93,0x94,0x97,0x96,0x91,0x98,0x8F,0x9A,0x9B,0x9C,0x9F,0x9E,0x98,0xA0,0xB7,0xA2,0xA3,0xA4,0xA7,0xA6,0xAF,0xA8,0xBF,0xAA,0xAB,0xAC,0xAF,0xAE,0xA6,0xB0,0xA7,0xB2,0xB3,0xB4,0xB7,0xB6,0xB4,0xB8,0xA0,0xBA,0xBB,0xBC,0xBE,0xBE,0xBE,0xC0,0xC0,0xC2,0xC3,0xC4,0xC1,0xC6,0xC2,0xC8,0xD2,0xCA,0xCB,0xCC,0xC8,0xCE,0xCD,0xD0,0xC6,0xD2,0xD3,0xD4,0xD3,0xD6,0xD3,0xD8,0xC3,0xDA,0xDB,0xDC,0xDF,0xDE,0xDF,0xE0,0xE0,0xE2,0xE3,0xE4,0xE6,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xEE,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0x85,0xF0,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFC,0xFE,0xFF,0x00,0x01,0x02,0x03,0x04,0x0A,0x00,0x07,0x08,0x3B,0x0A,0x0B,0x0C,0x1F,0x4E,0x2C,0x10,0x1B,0x12,0x35,0x14,0x1A,0x16,0x17,0x18,0x70,0x1A,0x1B,0x1C,0x0E,0x1E,0x3F,0x20,0x02,0x22,0x2A,0x24,0x03,0x26,0x35,0x28,0x29,0x2A,0x42,0x2C,0x2C,0x2E,0x21,0x30,0x31,0x31,0x37,0x34,0x31,0x36,0x37,0x38,0x92,0x91,0x90,0x97,0xF0,0xF3,0xF2,0x8D,0xAE,0xAD,0xAC,0xAB,0x3D,0x10,0x73,0x5A,0x49,0x49,0x4A,0x4C,0x6D,0x4E,0x4F,0x50,0x32,0x2E,0x36,0xBD,0xDB,0x07,0x86,0x81,0xC3,0x15,0x4D,0x68,0x84,0xFC,0xE1,0xD8,0x04,0x8C,0x2A,0x81,0x50,0x9D,0x49,0x84,0x08,0x61,0xA3,0x48,0x80,0xA1,0xFF,0xC5,0x70,0x72,0x72,0x74,0x74,0x76,0x77,0x78,0x64,0x7C,0x7B,0x7C,0x79,0x7E,0x7F,0x80,0xF1,0x92,0x8B,0x84,0x85,0x86,0x89,0x88,0x88,0x8A,0x8A,0x8C,0x8D,0x8E,0x8F,0x90,0xB3,0x94,0x93,0x94,0x90,0x96,0x97,0x98,0xA2,0x9A,0x9F,0x9C,0x4D,0x9E,0x9F,0xA1,0xAE,0xA2,0xA3,0xA4,0xA2,0xA6,0xA6,0xA8,0xAC,0xAA,0xAB,0xAC,0x86,0xA8,0xAF,0xB0,0x98,0xB2,0xB3,0xB4,0xA7,0xB7,0x96,0xD8,0x65,0xBA,0xBB,0xB4,0x64,0xBE,0xBF,0xC8,0xE0,0xA0,0x73,0xC6,0xE6,0xE4,0xCE,0xC8,0x44,0xC9,0x84,0xCF,0xCF,0xCF,0xEE,0xB3,0xA0,0x81,0xD9,0xD4,0xC3,0xD4,0xF6,0xF8,0xFA,0xD9,0xD2,0xDC,0xDC,0xCE,0xFE,0xD4,0xD4,0xA2,0xF1,0xE4,0x87,0xE2,0xE7,0xE8,0xFA,0xEF,0xCB,0xEC,0x9C,0xAE,0xEB,0xF0,0xF3,0xA6,0xFF,0xF0,0xE6,0xF3,0xFF,0xF8,0x88,0xAF,0xF1,0xFC,0xE9,0xFD,0x27,0x00,0x01,0x0A,0x2B,0xEA,0x14,0x05,0x07,0x08,0x19,0x0A,0x0F,0x0C,0x0F,0x0E,0x0F,0x10,0x2B,0x14,0x13,0x14,0x56,0x16,0x17,0x18,0x68,0x3A,0x1D,0x1C,0xC1,0x1E,0x13,0x24,0x33,0x22,0x67,0x27,0x21,0x26,0x35,0x38,0x6D,0x28,0x2F,0x2C,0x3F,0x2F,0x3B,0x35,0x88,0x4B,0x04,0xAA,0x27,0x36,0x73,0x3E,0x37,0x3A,0x29,0x2C,0x79,0x39,0x31,0x40,0x53,0x62,0x07,0x4C,0x4B,0x46,0x55,0x78,0x0D,0x43,0x45,0x4C,0x5F,0x4E,0x7A,0xA0,0x4D,0x52,0xE3,0x05,0xB5,0x5C,0x55,0x5C,0xE9,0x30,0xCB,0x57,0x5F,0x5F,0xE8,0xDA,0x80,0x69,0x61,0x61,0xD5,0x1D,0xD0,0xD2,0xD9,0xC9,0x8B,0x66,0x6E,0x6A,0xDF,0xFA,0xE1,0x79,0x70,0x75,0xC2,0xCC,0x96,0x73,0x7A,0x7F,0xCB,0xE7,0xCA,0xC4,0xCF,0x22,0x59,0x82,0x83,0x85,0xAD,0x63,0x95,0x88,0xC2,0x89,0x8F,0x8C,0x9F,0x9E,0xC4,0x92,0x95,0x92,0x81,0x94,0xE4,0xB6,0x92,0x98,0x9D,0x9A,0x97,0x9C,0x8C,0x9E,0x9F,0xA0,0xA7,0xA2,0xA1,0xA4,0xA5,0xA6,0xA7,0xA8,0xE7,0xAC,0xAB,0xAC,0x9A,0xAE,0xAF,0xB0,0x90,0xF2,0x53,0xB4,0xB5,0xB4,0x94,0xB9,0xB0,0xBA,0xA9,0xBC,0x9C,0xAC,0x8A,0xE5,0xEE,0xC2,0x1B,0xC6,0xC0,0xC5,0x83,0xCB,0xCD,0xCA,0x1E,0xFF,0x32,0xCE,0x42,0xE3,0x9E,0xD1,0xD2,0xD6,0x0D,0xD4,0xD2,0xDA,0x9D,0xD9,0xDF,0xDC,0x3C,0xDD,0xDC,0xE8,0x34,0xD1,0x1C,0xE4,0x68,0xD5,0xA8,0xEB,0xE8,0xE8,0x33,0xEE,0xE8,0xEF,0xAB,0xF3,0xF5,0xF2,0x12,0xF7,0xF6,0xE6,0x22,0xCB,0x06,0xFA,0x76,0xCF,0xB2,0xFD,0xFE,0x02,0x45,0x00,0x07,0x04,0xE4,0x04,0x05,0x10,0xDC,0x28,0xF4,0x0C,0x80,0x2C,0x40,0x12,0x10,0x17,0xCB,0x14,0x15,0x17,0xCF,0x1D,0x1C,0x1E,0x33,0xCD,0x0C,0x1F,0x1F,0x20,0x27,0x22,0x21,0x24,0x24,0x26,0x27,0x28,0x75,0x2C,0x2B,0x2C,0x19,0x2E,0x2F,0x30,0x10,0x72,0xD2,0x34,0x35,0x34,0x14,0x39,0x33,0x3A,0x29,0x3C,0x1C,0x7C,0x0A,0x65,0x6D,0x42,0x9B,0x46,0x40,0x45,0x0F,0x4A,0x4D,0x48,0x3A,0x5C,0x4F,0x4E,0x4D,0x50,0x5B,0x50,0x8B,0x57,0x50,0x54,0x1F,0x5B,0x5D,0x59,0x2A,0x4C,0x5F,0x5E,0x5C,0x60,0x6B,0x61,0x83,0x67,0x66,0x6E,0xD1,0x5A,0xB1,0x69,0x6E,0x6D,0x25,0x6D,0x6B,0x73,0x00,0x62,0x71,0x74,0x76,0x76,0x7D,0x7B,0x99,0x79,0x78,0x6C,0xCB,0x4C,0x37,0x83,0x85,0x87,0x63,0x87,0x86,0x9E,0x31,0xBA,0xC2,0x88,0x8A,0x8C,0x55,0x8E,0x8F,0x91,0x49,0x97,0x96,0x90,0xBD,0x42,0x86,0x99,0x9A,0x9A,0x9A,0x9C,0x9F,0x9E,0x9F,0xA0,0xCB,0xA4,0xA3,0xA4,0xAA,0xA6,0xA7,0xA8,0xC7,0xBA,0xA2,0xAC,0xAF,0xAE,0xA3,0xB0,0xC0,0xA2,0xB0,0xB4,0xB5,0xB6,0xBB,0xB8,0xDB,0xBB,0xBA,0xBC,0xCC,0x9E,0xB4,0xC0,0xD1,0xC2,0xC9,0xC4,0xCA,0xC6,0xC7,0xC8,0xC8,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD4,0xD2,0xD3,0xD4,0xD6,0xD6,0xD6,0xD8,0xDA,0xDA,0xDA,0xDC,0xDC,0xDE,0xDF,0xE0,0xE0,0xE2,0xE3,0xE4,0xE1,0xE6,0xE7,0xE8,0xEB,0xEA,0xEB,0xEC,0xE4,0xEE,0xE6,0xF0,0xF0,0xF2,0xF3,0xF4,0xFC,0xF6,0xF7,0xF8,0xFD,0xFA,0xFB,0xFC,0xF4,0xFE,0xFE,0x00,0x0B,0x02,0x02,0x04,0x07,0x06,0x07,0x08,0x03,0x0A,0x0A,0x0C,0x0F,0x0E,0x0F,0x10,0x18,0x12,0x12,0x14,0x1D,0x2A,0x74,0x74,0x70,0x74,0x72,0x68,0x23,0x1E,0x19,0x1C,0x48,0x4C,0x4A,0x50,0x1B,0x26,0x26,0x6A,0x29,0x20,0x68,0x44,0x48,0x4D,0x44,0x1E,0x5B,0x53,0x45,0x55,0x35,0x37,0x7E,0x38,0x3B,0x73,0x79,0x3C,0x3C,0x72,0x3F,0x42,0x0D,0x0E,0x43,0x47,0x09,0x0A,0x0E,0x48,0x4C,0x06,0x07,0x05,0x01,0x07,0x4F,0x5D,0x1D,0x31,0x3C,0x39,0x7A,0x37,0x78,0x1B,0x31,0x3F,0x38,0x37,0x66,0x5E,0x4D,0x2C,0x0B,0x03,0x15,0x05,0x4A,0x0A,0x06,0x06,0x0E,0x45,0x24,0x0E,0x07,0x0B,0x0C,0x04,0x4A,0x72,0x61,0x38,0x1F,0x17,0x01,0x19,0x56,0x16,0x1A,0x12,0x1A,0x51,0x2C,0xF4,0xF3,0xEB,0xED,0xE3,0xBE,0x86,0x95,0xC4,0xE3,0xEB,0xFD,0xED,0xA2,0xE2,0xEE,0xFE,0xF6,0xBD,0xC0,0xED,0xE6,0xE2,0xF2,0xF5,0xA2,0x9A,0x89,0xD0,0xF7,0xFF,0xE9,0xC1,0x8E,0xD7,0xD7,0xCD,0xC9,0x89,0xE6,0xDA,0xDB,0xCB,0xD2,0xDF,0x96,0xAE,0xAE,0xE6,0xB1,0xB4,0xE5,0xF8,0xFC,0xFA,0xFE,0xF1,0xB9,0xBB,0xE1,0xBC,0xBF,0xE4,0xF3,0xC0,0xC2,0x98,0x8F,0x88,0xC5,0xC4,0x9C,0x8A,0xC9,0xC8,0x90,0x85,0xCD,0xCF,0xAE,0xD0,0xD8,0xB3,0xA1,0xA6,0xB4,0xAF,0xB4,0xB7,0xA9,0xA3,0xDB,0xDD,0xBF,0xDE,0xDA,0x83,0x89,0x87,0x80,0x8F,0xE5,0xE0,0x82,0x99,0x9C,0x8B,0x87,0x9F,0xED,0xE6,0x88,0x95,0x85,0xB0,0x8A,0x80,0x90,0x85,0xF7,0xC4,0xF9,0xFD,0xF5,0xFE,0xE8,0x78,0xFD,0x6B,0xA5,0x00,0x16,0xC6,0x05,0x03,0x07,0x0F,0x07,0x0A,0x38,0x0D,0x0D,0x09,0x01,0x1F,0x3C,0x3C,0x13,0x50,0x14,0x16,0x10,0x05,0x43,0x51,0x27,0x57,0x56,0x22,0x98,0x77,0x1E,0x22,0x2B,0x20,0x25,0x26,0x27,0x28,0x2E,0x24,0x60,0x54,0x11,0xEA,0x12,0x2E,0x85,0x9D,0x72,0x08,0x09,0x36,0x10,0x3A,0x39,0x3A,0x3C,0x32,0x67,0x75,0xA9,0xF4,0xF5,0xD3,0x1C,0x44,0x59,0x44,0x47,0x48,0x4E,0x44,0x11,0x07,0x4C,0x59,0x40,0x8E,0x0C,0x52,0x07,0x55,0x55,0x51,0x59,0x58,0x5B,0x5A,0x53,0x5C,0x5D,0x54,0x5E,0x6A,0x61,0xEA,0xE3,0x60,0xF1,0x62,0x66,0xE9,0xE9,0x6E,0xE3,0x69,0x6C,0x64,0xCF,0x75,0x70,0x7B,0xCF,0x71,0x74,0x7E,0xD7,0x7E,0x78,0x70,0xC3,0x7B,0x7C,0x74,0xC7,0x88,0x80,0x8B,0x33,0x8D,0x88,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8C,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x94,0x96,0x97,0x98,0x85,0x9A,0x9B,0x9C,0xED,0x9E,0x9F,0xA0,0xA3,0xA2,0xA3,0xA4,0xAE,0xA6,0xA7,0xA8,0x49,0xAA,0xAB,0xAC,0xAE,0xAE,0xAF,0xB0,0xBB,0xB2,0xB3,0xB4,0xB9,0xB7,0xB7,0xB8,0xBD,0xBA,0xBB,0xBC,0xBF,0xBE,0xBF,0xC0,0x45,0xC3,0xC3,0xC4,0xC0,0xC6,0xC7,0xC8,0xC5,0xCA,0xCB,0xCC,0x59,0xCF,0xCF,0xD0,0xD7,0xD2,0xD3,0xD4,0xD4,0xD6,0xD7,0xD8,0x2D,0xDB,0xDB,0xDC,0xDC,0xFE,0xDF,0xE0,0xE9,0xE2,0xE3,0xE4,0xF1,0xE4,0xE7,0xE8,0xE8,0xFA,0xEB,0xEC,0xE5,0xEE,0xEF,0xF0,0x11,0xF6,0xF3,0xF4,0xF7,0xD6,0xF7,0xF8,0xE5,0xFA,0xFB,0xFC,0xD1,0xFB,0xFF,0x00,0x02,0x22,0x03,0x04,0x0D,0x06,0x07,0x08,0x06,0x0C,0x0B,0x0C,0x0D,0x2E,0x0F,0x10,0x10,0x12,0x13,0x14,0x65,0x10,0x17,0x18,0x19,0x0A,0x1B,0x1C,0x1C,0x1E,0x1F,0x20,0xBD,0x24,0x23,0x24]v9 = 233out = &quot;&quot;for i in range(0x73c): tmp = (a[i]^v9)&amp;0xFF out += chr(tmp) v9 += 1fp = open(&quot;claz2.dex&quot;, &quot;wb&quot;)fp.write(out)fp.close() Tea的加解密程序：该java版本还是较为标准的实现，可以收藏。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package hitb2018;public class Tea &#123; private final static int[] KEY = new int[]&#123;//加密解密所用的KEY 0xABABABAB, 0xCDCDCDCD, 0xEFEFEFEF, 0x12345678 &#125;; //加密 public static byte[] encrypt(byte[] content, int offset, int[] key, int times)&#123;//times为加密轮数 int[] tempInt = byteToInt(content, offset); int y = tempInt[0], z = tempInt[1], sum = 0, i; int delta=0x9e3779b9; //这是算法标准给的值 int a = key[0], b = key[1], c = key[2], d = key[3]; for (i = 0; i &lt; times; i++) &#123; sum += delta; y += ((z&lt;&lt;4) + a) ^ (z + sum) ^ ((z&gt;&gt;5) + b); z += ((y&lt;&lt;4) + c) ^ (y + sum) ^ ((y&gt;&gt;5) + d); &#125; tempInt[0]=y; tempInt[1]=z; return intToByte(tempInt, 0); &#125; //解密 public static byte[] decrypt(byte[] encryptContent, int offset, int[] key, int times)&#123; int[] tempInt = byteToInt(encryptContent, offset); int y = tempInt[0], z = tempInt[1], sum = 0, i; int delta=0x9e3779b9; //这是算法标准给的值 int a = key[0], b = key[1], c = key[2], d = key[3]; if (times == 32) sum = 0xC6EF3720; /* delta &lt;&lt; 5*/ else if (times == 16) sum = 0xE3779B90; /* delta &lt;&lt; 4*/ else sum = delta * times; for(i = 0; i &lt; times; i++) &#123; z -= ((y&lt;&lt;4) + c) ^ (y + sum) ^ ((y&gt;&gt;5) + d); y -= ((z&lt;&lt;4) + a) ^ (z + sum) ^ ((z&gt;&gt;5) + b); sum -= delta; &#125; tempInt[0] = y; tempInt[1] = z; return intToByte(tempInt, 0); &#125; //byte[]型数据转成int[]型数据 private static int[] byteToInt(byte[] content, int offset)&#123; int[] result = new int[content.length &gt;&gt; 2];//除以2的n次方 == 右移n位 即 content.length / 4 == content.length &gt;&gt; 2 for(int i = 0, j = offset; j &lt; content.length; i++, j += 4)&#123; result[i] = transform(content[j + 3]) | transform(content[j + 2]) &lt;&lt; 8 | transform(content[j + 1]) &lt;&lt; 16 | (int)content[j] &lt;&lt; 24; &#125; return result; &#125; //int[]型数据转成byte[]型数据 private static byte[] intToByte(int[] content, int offset)&#123; byte[] result = new byte[content.length &lt;&lt; 2];//乘以2的n次方 == 左移n位 即 content.length * 4 == content.length &lt;&lt; 2 for(int i = 0, j = offset; j &lt; result.length; i++, j += 4)&#123; result[j + 3] = (byte)(content[i] &amp; 0xff); result[j + 2] = (byte)((content[i] &gt;&gt; 8) &amp; 0xff); result[j + 1] = (byte)((content[i] &gt;&gt; 16) &amp; 0xff); result[j] = (byte)((content[i] &gt;&gt; 24) &amp; 0xff); &#125; return result; &#125; //若某字节为负数则需将其转成无符号正数 private static int transform(byte temp)&#123; int tempInt = (int)temp; if(tempInt &lt; 0)&#123; tempInt += 256; &#125; return tempInt; &#125; public static void main(String[] args)&#123; byte[] enContent = new byte[]&#123;99, 124, 101, -23, -114, 81, -47, -39, -102, 79, 22, 52, -39, -94, -66, -72, 101, -18, 73, -27, 53, -5, 46, -20, 97, 11, -56, 36, -19, -49, -112, -75&#125;; for(int j=0;j&lt;4;j++)&#123; byte[] deContent = decrypt(enContent,j*8,KEY,32); for(int i = 0;i &lt; 8;i++)&#123; System.out.print((char)deContent[i]); &#125; &#125; &#125;&#125; 其实对整个程序的动态加载和替换过程还不是很了解。题目有点小坑，但是还能接受。HITB{SEe!N9_IsN’T_bELIEV1Ng} kivy simpleapk包有点大，但是安装以后也没有特别的功能。首先搜索kivy，kivy是使用python进行全平台应用开发的框架，该apk也是使用该python框架进行开发的，通过JEB对java代码以及IDA对so文件的分析，并没有发现程序的主逻辑。进一步，通过学习kivy框架的开发以及程序打包流程，同时注意到了解压缩后在assets中的private.mp3文件，猜测为压缩包。 修改文件名后缀，解压得到部分文件(这里注意，在不同平台下可能要解压两次，比如windows下) 找到了python 编写的主函数等文件使用uncompyle6对main.pyo得到main.py：其中有一段：123456789101112def check(self): if self.flag.text == &apos;HITB&#123;this_is_not_flag&#125;&apos;: return True return Falsedef auth(self, instance): if self.check(): s = &apos;Congratulations you got the flag&apos; else: s = &apos;Wrong answer&apos; popup = Popup(title=&apos;result&apos;, content=Label(text=s), auto_dismiss=True) popup.open() 逻辑很简单，但HITB{this_is_not_flag}不是答案，还是骗人的。注意到：12b64 = &apos;eJzF1MtOE2EUB/DzTculUKAUKJSr3OqIV0TBGEOMRqIuatJhowsndTrVA+MlnYEYhZXEhQuXLlz4CC58BBc+ggsfwYWPYDznhHN8BJr5Tv7fby6Z8/VrIzj+eDRu0kirVFoARwCPAGI6HOx4EBI6CHy+LHLH1/O4zfd8onQAsEOHg0MHmQcHDt45vmc3B50FyHIQELU8qLZyYutmebIusftm3WQ9Yo/NeskKYh2zPrJ+sfdmRbIBsc9mg2RDYl/NSmTDYt/NymQjYj/NRsnGxH6bVcjGxf6aTZBVxcpObdL6rZlNkU2LXTebsT7qZrP2fk/M5shOie2bzdvzPpgtkC2KfTFbIlsW+2ZWIzst9sPMJzsj9stsheys2B+zc2TnxTxP7YL1UTG7aLZidolsVWzT7LL11jBbI7si1ja7SrYu9sZsw+yjWJaHgHZx4F+j/VnHOao4TCXjvbuBQxqXsV9jgDmNt7CiMURP4zZOaXyA3RrncVTjEpY0djCv8S2Oa3yF/OtC0PldLPN8hkuf4ioO8nxA5zWc1LiITuM97NG4hbMaD3FE4z4W+TEFLhOKD7GL59M6r+OYxjXsperz+YzfvZ00n0rI4tdZxkuTxC8yPr3VTNJYTm139mL5S5BZGidteVTqc4dSMil8V/Qsjnb52vSIzRVdGfKu5E5seHWfu2rw3sj460yjTkwt8oqFYZQ00zQM/3cipSErzQt14/nL1l4Sb0pHXAp3/gENPMQt&apos;eval(marshal.loads(zlib.decompress(binascii.a2b_base64(b64)))) 说明程序可能进行了动态的加载和替换。将zlib.decompress(binascii.a2b_base64(b64))后的内容实际上是PythonCodeObject对象，通过查找资料，可以将该对象转化为.pyc文件，进而反编译。转换代码：123456789101112131415161718192021import py_compileimport impimport osimport binasciiimport zlibimport marshaldef pycodeobject2pyc(pyobj, pycfile): with open(pycfile, &apos;wb&apos;) as fc: fc.write(&apos;\\0\\0\\0\\0&apos;) timestamp = long(os.fstat(fc.fileno()).st_mtime) py_compile.wr_long(fc, timestamp) marshal.dump(pyobj, fc) fc.flush() fc.seek(0, 0) MAGIC = imp.get_magic() fc.write(MAGIC)if __name__ == &quot;__main__&quot;: b64 = &apos;eJzF1MtOE2EUB/DzTculUKAUKJSr3OqIV0TBGEOMRqIuatJhowsndTrVA+MlnYEYhZXEhQuXLlz4CC58BBc+ggsfwYWPYDznhHN8BJr5Tv7fby6Z8/VrIzj+eDRu0kirVFoARwCPAGI6HOx4EBI6CHy+LHLH1/O4zfd8onQAsEOHg0MHmQcHDt45vmc3B50FyHIQELU8qLZyYutmebIusftm3WQ9Yo/NeskKYh2zPrJ+sfdmRbIBsc9mg2RDYl/NSmTDYt/NymQjYj/NRsnGxH6bVcjGxf6aTZBVxcpObdL6rZlNkU2LXTebsT7qZrP2fk/M5shOie2bzdvzPpgtkC2KfTFbIlsW+2ZWIzst9sPMJzsj9stsheys2B+zc2TnxTxP7YL1UTG7aLZidolsVWzT7LL11jBbI7si1ja7SrYu9sZsw+yjWJaHgHZx4F+j/VnHOao4TCXjvbuBQxqXsV9jgDmNt7CiMURP4zZOaXyA3RrncVTjEpY0djCv8S2Oa3yF/OtC0PldLPN8hkuf4ioO8nxA5zWc1LiITuM97NG4hbMaD3FE4z4W+TEFLhOKD7GL59M6r+OYxjXsperz+YzfvZ00n0rI4tdZxkuTxC8yPr3VTNJYTm139mL5S5BZGidteVTqc4dSMil8V/Qsjnb52vSIzRVdGfKu5E5seHWfu2rw3sj460yjTkwt8oqFYZQ00zQM/3cipSErzQt14/nL1l4Sb0pHXAp3/gENPMQt&apos; data = marshal.loads(zlib.decompress(binascii.a2b_base64(b64))) pycodeobject2pyc(data, &quot;apk2.pyc&quot;) 该段代码参考了https://segmentfault.com/q/1010000003052356 PythonCodeObject转换为.pyc也费了一番功夫，基础不扎实，不知道该怎么处理。太菜了。再次用uncompyle6进行反编译得到真正的check代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970def check(self): s = self.flag.text if len(s) != 31: return False if s[17] != &apos;7&apos;: return False if s[15] != &apos;%&apos;: return False if s[11] != &apos;S&apos;: return False if s[3] != &apos;B&apos;: return False if s[22] != &apos;_&apos;: return False if s[2] != &apos;T&apos;: return False if s[27] != &apos;O&apos;: return False if s[6] != &apos;!&apos;: return False if s[20] != &apos;$&apos;: return False if s[16] != &apos;r&apos;: return False if s[4] != &apos;&#123;&apos;: return False if s[23] != &apos;p&apos;: return False if s[25] != &apos;7&apos;: return False if s[0] != &apos;H&apos;: return False if s[18] != &apos;_&apos;: return False if s[29] != &apos;!&apos;: return False if s[10] != &apos;1&apos;: return False if s[14] != &apos;H&apos;: return False if s[13] != &apos;&amp;&apos;: return False if s[26] != &apos;#&apos;: return False if s[1] != &apos;I&apos;: return False if s[7] != &apos;F&apos;: return False if s[30] != &apos;&#125;&apos;: return False if s[19] != &apos;v&apos;: return False if s[12] != &apos;_&apos;: return False if s[9] != &apos;_&apos;: return False if s[24] != &apos;Y&apos;: return False if s[5] != &apos;1&apos;: return False if s[28] != &apos;N&apos;: return False if s[21] != &apos;3&apos;: return False if s[8] != &apos;3&apos;: return False return Truescreen.__class__.check = check! 此处才是真正进行逻辑判断的函数手动排序得到flag：HITB{1!F3_1S_&amp;H%r7_v$3_pY7#ON!}","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://www.w4ter5heep.com/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.w4ter5heep.com/tags/CTF/"},{"name":"Mobile","slug":"Mobile","permalink":"http://www.w4ter5heep.com/tags/Mobile/"}]},{"title":"hellow_my_site","slug":"hellow-my-site","date":"2018-04-05T09:19:55.000Z","updated":"2018-04-15T15:24:44.871Z","comments":true,"path":"2018/04/05/hellow-my-site/","link":"","permalink":"http://www.w4ter5heep.com/2018/04/05/hellow-my-site/","excerpt":"","text":"can you see my secret","categories":[{"name":"Welcome!","slug":"Welcome","permalink":"http://www.w4ter5heep.com/categories/Welcome/"}],"tags":[{"name":"MySite","slug":"MySite","permalink":"http://www.w4ter5heep.com/tags/MySite/"}]}]}