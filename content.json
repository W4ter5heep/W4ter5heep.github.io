{"meta":{"title":"W4ter5heep's site","subtitle":null,"description":"Coding is fun!","author":"W4ter5heep","url":"http://www.w4ter5heep.com"},"pages":[{"title":"categories","date":"2018-04-06T01:09:53.000Z","updated":"2018-04-06T01:12:30.232Z","comments":true,"path":"categories/index.html","permalink":"http://www.w4ter5heep.com/categories/index.html","excerpt":"","text":""},{"title":"FriendLinks","date":"2018-04-06T01:48:23.000Z","updated":"2018-04-15T15:35:38.650Z","comments":true,"path":"friendlinks/index.html","permalink":"http://www.w4ter5heep.com/friendlinks/index.html","excerpt":"","text":"我我我最菜"},{"title":"tags","date":"2018-04-06T01:29:00.000Z","updated":"2018-04-06T01:29:22.101Z","comments":true,"path":"tags/index.html","permalink":"http://www.w4ter5heep.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"StarCTF-BabyDroid","slug":"StarCTF-BabyDroid","date":"2018-05-01T16:04:08.000Z","updated":"2018-05-01T16:30:24.660Z","comments":true,"path":"2018/05/02/StarCTF-BabyDroid/","link":"","permalink":"http://www.w4ter5heep.com/2018/05/02/StarCTF-BabyDroid/","excerpt":"","text":"逆向题目中唯一一道android逆向，做出来的过程也比较费力，这里简单记录。 安装程序发现会闪退，可能有反调试措施，首先进行静态分析。JEB查看Java代码部分： Alt text 关键方法是check0，同时注意到上面有许多check函数的native声明： Alt text 从so文件中查找相关方法。首先在liba.so中找到了check0函数：发现进一步调用的是check函数，但是在liba中没有相关信息，查找libb，没有直接找到check函数，考虑JNIOnLoad进行了注册，但是也没有找到JNIOnLoad函数，查找发现了sub_ED8函数： Alt text 对一部分数据进行了解密，同时发现了： Alt text Alt text 所以JNIOnLoad函数会在运行时才解密：解密的关键是这个值： Alt text 进入sub_9B4发现计算的应该是一个校验和，分析程序逻辑，写出计算校验和的脚本：1234567891011121314def crc32(ss): v2 = i32(-1) v7 = i32() for s in ss: if isinstance(s, bytes): s = s[0] for i in range(8): v7.value = v2.value ^ (s &gt;&gt; i &lt;&lt; 31) v2.value *= 2 if v7.value &lt;= -1: # if not 0x4C11DB7 &amp; 1: # v2.value ^= 1 v2.value ^= 0x4C11DB7 return u32(-v2.value).value - 1 得到libb的校验和：0x6674632a解密libb.so可以得到JNIOnLoad： Alt text 这里也进行了注册，将相关字符串进行解密可以发现就是对check函数的注册，解密脚本：1234567891011121314151617181920212223242526272829303132def xorstr(): def get_result(nums, key): nums = [[((i &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] for i in nums] # nums = sum(nums, []) nums = list(itertools.chain.from_iterable(nums)) nums = [i ^ key for i in itertools.takewhile(lambda i: i != 0, nums)] b = bytes(nums) return b nums = [0xBCFEFCF0, 0xEAE9A1E2, 0xF1F2F1BC, 0xF7FDF2EA, 0xF7FAFCE1, 0xFAF2DEBC, 0xE7F0D2FD, 0xE7FAE5FA, 0xea] print(get_result(nums, 0x93)) nums = [0x777C5A3E, 0x7A397760, 0x39717877, 0x7F646245, 0x3F2D7178, 0x4C] print(get_result(nums, 0x16)) nums = [0x73757873, 0x7B] print((get_result(nums, 0x10))) 解密结果为：com/q2zy/babyandroid/MainActivity (Ljava/lang/String;)Z check Alt text 即是注册的函数，但是发现依然是乱码，注意到下面还有一段解密： Alt text 这里用到了liba.so的校验和，计算发现也是0x6674632a解密得到check 函数： Alt text 再次用到了liba.so的校验和，分析逻辑写出解密脚本：1234567891011121314151617181920212223242526272829303132333435363738def get_flag(): crc = crc32(open(&apos;/Users/alset/Downloads/apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) crc2 = crc * crc checksums = [((crc2 &gt;&gt; (j * 8)) &amp; 0xff) for j in range(8)] b = bytearray([ 0xD5, 8, 0x4B, 0x11, 0xBF, 0xC, 0xB, 0x1F, 0xDC, 0x57, 0x64, 0x74, 0xB4, 0x6D, 0x5B, 0xD4, 0xEB, 0x1D, 0x51, 0xAE, 0xD5, 0x44, 8, # 0 ]) for i in range(8): for j in range(8): b[i + j] ^= checksums[j] i = 15 for j in range(8): b[i + j] ^= checksums[j] print(b) 得到flag：1nTr3stIng-AnDr0id-A&amp;D!完整解密脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import osimport mmapimport itertoolsfrom ctypes import c_int32 as i32, c_uint32 as u32def memory_map(filename, access=mmap.ACCESS_COPY): size = os.path.getsize(filename) fd = os.open(filename, os.O_RDWR) return mmap.mmap(fd, size, access=access)def crc32(ss): v2 = i32(-1) v7 = i32() for s in ss: if isinstance(s, bytes): s = s[0] for i in range(8): v7.value = v2.value ^ (s &gt;&gt; i &lt;&lt; 31) v2.value *= 2 if v7.value &lt;= -1: # if not 0x4C11DB7 &amp; 1: # v2.value ^= 1 v2.value ^= 0x4C11DB7 return u32(-v2.value).value - 1def recoverlibb(): m = memory_map(&apos;./apk/lib/armeabi-v7a/libb.so&apos;) start = 0xab8 size = 0x420 # right_asm = [0xf0, 0xb5, 0x3, 0xaf] # checksums = [m[start + i] ^ right_asm[i] for i in range(len(right_asm))] checksum = crc32(m) checksums = [((checksum &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] ichecksums = itertools.cycle(checksums) for i in range(size): m[start + i] = m[start + i] ^ next(ichecksums) start += 0x27C size -= 0x27C for i in range(0, , 4): m[start + i], m[start + i + 1], m[start + i + 2], m[start + i + 3] = m[start + i + 2], m[start + i + 3], m[ start + i], m[start + i + 1] # right_asm = [0xFF, 0xF7, 0x3E, 0xEE] # checksums = [m[start + size - 4 + i] ^ right_asm[i] for i in range(len(right_asm))] checksum = crc32(open(&apos;./apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) print(&apos;a: &apos;, checksum) checksums = [((checksum &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] ichecksums = itertools.cycle(checksums) for i in range(size): m[start + i] = m[start + i] ^ next(ichecksums) m.seek(0) open(&apos;./apk/lib/armeabi-v7a/libbnew2.so&apos;, &apos;wb&apos;).write(m.read())def xorstr(): def get_result(nums, key): nums = [[((i &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] for i in nums] # nums = sum(nums, []) nums = list(itertools.chain.from_iterable(nums)) nums = [i ^ key for i in itertools.takewhile(lambda i: i != 0, nums)] b = bytes(nums) return b nums = [0xBCFEFCF0, 0xEAE9A1E2, 0xF1F2F1BC, 0xF7FDF2EA, 0xF7FAFCE1, 0xFAF2DEBC, 0xE7F0D2FD, 0xE7FAE5FA, 0xea] print(get_result(nums, 0x93)) nums = [0x777C5A3E, 0x7A397760, 0x39717877, 0x7F646245, 0x3F2D7178, 0x4C] print(get_result(nums, 0x16)) nums = [0x73757873, 0x7B] print((get_result(nums, 0x10)))def get_flag(): crc = crc32(open(&apos;./apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) crc2 = crc * crc checksums = [((crc2 &gt;&gt; (j * 8)) &amp; 0xff) for j in range(8)] b = bytearray([ 0xD5, 8, 0x4B, 0x11, 0xBF, 0xC, 0xB, 0x1F, 0xDC, 0x57, 0x64, 0x74, 0xB4, 0x6D, 0x5B, 0xD4, 0xEB, 0x1D, 0x51, 0xAE, 0xD5, 0x44, 8, # 0 ]) for i in range(8): for j in range(8): b[i + j] ^= checksums[j] i = 15 for j in range(8): b[i + j] ^= checksums[j] print(b)if __name__ == &apos;__main__&apos;: # xorstr() # recoverlibb() get_flag()","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://www.w4ter5heep.com/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.w4ter5heep.com/tags/CTF/"},{"name":"Mobile","slug":"Mobile","permalink":"http://www.w4ter5heep.com/tags/Mobile/"}]},{"title":"hellow_my_site","slug":"hellow-my-site","date":"2018-04-05T09:19:55.000Z","updated":"2018-04-15T15:24:44.871Z","comments":true,"path":"2018/04/05/hellow-my-site/","link":"","permalink":"http://www.w4ter5heep.com/2018/04/05/hellow-my-site/","excerpt":"","text":"can you see my secret","categories":[{"name":"Welcome!","slug":"Welcome","permalink":"http://www.w4ter5heep.com/categories/Welcome/"}],"tags":[{"name":"MySite","slug":"MySite","permalink":"http://www.w4ter5heep.com/tags/MySite/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-04-05T02:35:01.800Z","updated":"2018-04-15T15:25:04.899Z","comments":true,"path":"2018/04/05/hello-world/","link":"","permalink":"http://www.w4ter5heep.com/2018/04/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Welcome!","slug":"Welcome","permalink":"http://www.w4ter5heep.com/categories/Welcome/"}],"tags":[{"name":"MySite","slug":"MySite","permalink":"http://www.w4ter5heep.com/tags/MySite/"}]}]}