{"meta":{"title":"W4ter5heep's site","subtitle":null,"description":"Coding is fun!","author":"W4ter5heep","url":"http://www.w4ter5heep.com"},"pages":[{"title":"tags","date":"2018-04-06T01:29:00.000Z","updated":"2018-04-06T01:29:22.101Z","comments":true,"path":"tags/index.html","permalink":"http://www.w4ter5heep.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-06T01:09:53.000Z","updated":"2018-04-06T01:12:30.232Z","comments":true,"path":"categories/index.html","permalink":"http://www.w4ter5heep.com/categories/index.html","excerpt":"","text":""},{"title":"FriendLinks","date":"2018-04-06T01:48:23.000Z","updated":"2018-04-15T15:35:38.650Z","comments":true,"path":"friendlinks/index.html","permalink":"http://www.w4ter5heep.com/friendlinks/index.html","excerpt":"","text":"我我我最菜"}],"posts":[{"title":"demo","slug":"demo","date":"2018-06-04T13:01:02.000Z","updated":"2018-06-04T13:01:02.848Z","comments":true,"path":"2018/06/04/demo/","link":"","permalink":"http://www.w4ter5heep.com/2018/06/04/demo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SUCTF复盘——三个RE","slug":"SUCTF复盘——三个RE","date":"2018-06-04T12:34:06.000Z","updated":"2018-06-04T13:02:00.303Z","comments":true,"path":"2018/06/04/SUCTF复盘——三个RE/","link":"","permalink":"http://www.w4ter5heep.com/2018/06/04/SUCTF复盘——三个RE/","excerpt":"","text":"RoughLike与期末大作业.Net逆向首先承认，比赛的时候因为手比较快下载的是有img文件夹的压缩包，但是很迷，上午提交截图的flag提示错误，下午就对了。。。 Alt text Alt text 更新后题目的目录结构如下： Alt text 可以发现dll文件非常大，反倒是主程序比较小在test_Data中找到比较多的文件但好像运行报错？ Alt text 还要改文件夹名字。。。 hint提示要看过场动画首先可以看到开始的过场动画： Alt text 说明flag有两段？有点牵强。。。 尝试玩了几关，没什么发现，并且动作缓慢 得到第二段flag的一种方法：查看Data文件夹中的level1文件，使用010editor直接搜索字符串，找到： Alt text 得到第二段flag：_70_5uc7F有点不讲道理 得到第一段flag方法：首先要知道Managed文件夹中Dotfuscated是因为对.NET进行了混淆：使用De4dot对Dotfuscated的Assembly-CSharp.dll进行去混淆，该工具在吾爱破解工具包中就有。然后使用.NET Reflator进行反编译，搜索关键词找到关键函数： Alt text 有两个decrypt函数： Alt text 内容： Alt text Alt text 满足这两个条件即会在地图上随机位置生成一个flag，但是条件比较苛刻：12&lt;&lt;8|12&gt;&gt;0x18目测是一个很大的数第二个也同样 可以通过修改初始参数值使条件满足，但是这里想办法分析函数：这里要查找S3cretArray数组初始化的位置是LoadBundle： Alt text 继续追踪到解密函数：DecryptAssetBundle( Alt text 前几天刚做了一个题，目测是索引表变了以后的base64 要解密的文件是： Alt text 解密脚本：12345678910111213141516171819202122import stringimport base64 custom = &quot;QRSTUVWXYZABCDEFGHIJKLMNOPabcdefghijklmnopqrstuvwxyz0123456789+/&quot;standard= &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; plainText=&quot;GetProcAddr&quot; def decryptbundle(pathname,dst): decode=&quot;&quot; with open(&quot;/Users/ilan/Desktop/SUCTF/re/Output/test_Data/StreamingAssets/bundles/%s&quot;%(pathname),&quot;rb&quot;) as f: encode=f.read() for ch in encode: if(ch in custom): decode=decode+standard[string.find(custom,str(ch))] elif(ch == &apos;=&apos;): decode= decode+&apos;=&apos; decode=base64.b64decode(decode) with open(dst,&quot;wb&quot;) as f: f.write(decode) decryptbundle(&quot;WeaponYourself.assetbundle&quot;,&quot;ext1&quot;) 此时对解密后的文件进行解析即可：利用工具解析文件，中间需要经过一步解压缩，搜索二进制文件的“flag”可以得到： Alt text 第一部分flag的base64也可以使用python的第三方库解压读取文件内容：https://github.com/HearthSim/UnityPack 在此基础上，可以通过分析代码的方式找到前半段Flag：在场景初始化函数中找到： Alt text 满足判断条件会设置为True条件为满足关卡数目和99整除且defeatedBoss数量大于0x72000000且defeatedMonster大于514时，会设置一个文本SPText标志位为true。 不可能完成的任务 因此可以直接设置SPText标志为True： Alt text 然后重新进入游戏就会直接显示flag了 官方的wp比较简单，通过修改程序执行逻辑使flag可以在程序运行时就显示flag以及相关道具 simpleformat就是一个printf输出格式化的问题程序逻辑比较简单： Alt text 需要输入36个字符，主要变换在sub_4006F6函数，然后将数据写入了/dev/null该函数比较恶心，有一大堆的dprintf Alt text 分析这一大堆奇怪的字符串，可以发现一些规律：格式基本类似于%1$*2$s，每个函数中字符串的结尾都是%20$n首先要知道参数的用法：%n指的是向任意地址写入任意值，作用是将之前输出的字符个数写入对应的参数指向的地址printf的$的用法则是指定这个格式串解析的参数偏移量。%2$s即为取出后面的第2个参数，以%s的形式输出。因此%20$n就是将之前输出的字符个数写到第20个参数的地址里。即unk_627200用于计数，因此每个dprintf最后第20个参数都是一个int数组中的元素，并且是用于memcmp的比较接下来就是每次写入的字符数量是如何获得的，分析%1$*2$s格式的含义*有指定宽度的效果，宽度取自后面的参数，%1$*2$s就是将第一个参数以第二个参数的宽度输出当输出%1$*2$s的串之后，当前输出长度即为第二个参数。继续遇到%1$*2$s则再次输出第二个参数长度，当前输出长度就变成了两倍第二个参数，最后会将输出总长度写入unk_627200因此起到了一个求和的效果：n1l1 + n2l3 + …… + n19*l19 = m1······总共18个方程，18元一次方程组大佬的脚本：123456789101112131415161718192021222324252627282930313233343536373839from zio import *from z3 import *formats = [] #数据太多太长给删掉了。。。可以自己补results = [5462280L, 4346506L, 5891159L, 6839864L, 7912833L, 7049790L, 7455784L, 7311612L, 6299256L, 7114100L, 7037043L, 6873051L, 5644794L, 8014197L, 6432215L, 6638450L, 6959905L, 6705884L]print len(formats)print len(results)s = Solver()d = [BitVec(&quot;d&#123;0&#125;&quot;.format(i), 16) for i in range(18)]for j in range(len(formats)): fmt = formats[j] left = 0 left_str = &apos;&apos; for i in range(2, 20): c = &apos;%1$*&apos;+str(i)+&apos;$s&apos; left += fmt.count(c)*d[i-2] #left_str += str(fmt.count(c))+&apos;*d[&apos;+str(i-2)+&apos;] + &apos; #print left_str s.add(left == results[j])print s.check()print s.model()model = s.model()init_state = &#123;&#125;for k in model: idx = int(str(k)[1:]) val = model[k].as_long() #print idx, val init_state[idx] = valflag = &apos;&apos;for i in range(18): flag += l16(init_state[i])print flag 注意细节，flag每两位作为了一个数伏地膜 enigma即二战时德国所使用的转轮密码机简单查看了密码机的原理，实际上enigma采用复式字母替换加密方法，利用键盘、转子、跳线、反射板、显示器进行对称加密/解密。Enigma属于算法和密钥分离的加密方法，破解Enigma的难度在于不知道当前密钥，包括转子的初始位置和跳线设置。 Alt text Alt text 查找关键函数，根据官方wp，程序实现了转轮机，线性反馈移位寄存器，换位器等输入： Alt text 长度要求是36最后经过比较要相等： Alt text 中间三个处理函数： Alt text sub_124F Alt text Alt text 单个取输入字符进行处理，然后写入最后用于比较的outstr sub_F1E Alt text Alt text sub_11F0 Alt text 因此对于输入的处理都是线性的，有爆破的可能断点下在： Alt text 然后对存储结果处的数据进行比较： Alt text Alt text 这是比较取巧的方法，需要自动调用gdb 出题人的本意是对程序进行生逆，把密文逆成明文。。。也有队伍是这么做的，服：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162with open(&apos;Enigma&apos;, &apos;rb&apos;) as f: input_enc = list(f.read()[0x30a0:][:36])def bit(a, b): return (a &gt;&gt; b) &amp; 1# sub_11F0state = 0x5F3759DFfor i in range(9): v16 = bit(state, 0) ^ bit(state, 2) ^ bit(state, 3) ^ bit(state, 5) ^ bit(state, 7) ^ bit(state, 31) state = (state &gt;&gt; 1) | (v16 &lt;&lt; 31) for j in range(4): input_enc[i*4 + j] ^= (state &gt;&gt; (j*8)) &amp; 0xff# sub_F1Edef partialRev(c): c = bin(c)[2:].rjust(8, &apos;0&apos;) c = list(map(int, c)) r = list(reversed(c)) c = r[:3] + c[3:5] + r[5:] return int(&apos;&apos;.join(map(str, c)), 2)input_enc = list(map(partialRev, input_enc))# sub_124Fwire = [ [ 0x31, 0x62, 0x93, 0xC4 ], [ 0x21, 0x42, 0x63, 0x84 ], [ 0x3D, 0x7A, 0xB7, 0xF4 ], ]def _mix(a1, a2, a3): a5 = a3 ^ a2 ^ a1 a4 = a2 &amp; a1 | a3 &amp; (a2 | a1) return (a4, a5)def mix(a2, v16, a4): bits = [] for i in range(8): v4 = bit(a2, i) v5 = bit(v16, i) a4, a5 = _mix(v5, v4, a4) bits.insert(0, a5) return int(&apos;&apos;.join(map(str, bits)), 2), a4flag = []for i, t in enumerate(input_enc): for c in range(32, 128): a4 = 0 v16 = c a2 = wire[0][i%4] v16, a4 = mix(a2, v16, a4) a2 = wire[1][(i//4%4)] v16, a4 = mix(a2, v16, a4) a2 = wire[2][i//16] v16, a4 = mix(a2, v16, a4) if v16 == t: flag.append(c) breakprint(bytes(flag).decode(&apos;ascii&apos;)) 首先获取最后结果：1234with open(&apos;Enigma&apos;, &apos;rb&apos;) as f: input_enc = list(f.read()[0x30a0:][:36])print(input_enc) 然后得到sub_11F0异或之前的结果 Alt text 该值是不是可以动态调试得到，内部有好多子函数，没有仔细分析123456state = 0x5F3759DFfor i in range(9): v16 = bit(state, 0) ^ bit(state, 2) ^ bit(state, 3) ^ bit(state, 5) ^ bit(state, 7) ^ bit(state, 31) state = (state &gt;&gt; 1) | (v16 &lt;&lt; 31) for j in range(4): input_enc[i*4 + j] ^= (state &gt;&gt; (j*8)) &amp; 0xff 然后是sub_F1E的逆向： Alt text 1234567def partialRev(c): c = bin(c)[2:].rjust(8, &apos;0&apos;) c = list(map(int, c)) r = list(reversed(c)) c = r[:3] + c[3:5] + r[5:] return int(&apos;&apos;.join(map(str, c)), 2)input_enc = list(map(partialRev, input_enc)) 也是看起来比较头疼的函数 最后是sub_124F，因为比较复杂，采用了正向python模拟实现然后爆破的方式： Alt text 没有勇气看下去。。。。12345678910111213141516171819wire = [ [ 0x31, 0x62, 0x93, 0xC4 ], [ 0x21, 0x42, 0x63, 0x84 ], [ 0x3D, 0x7A, 0xB7, 0xF4 ], ]def _mix(a1, a2, a3): a5 = a3 ^ a2 ^ a1 a4 = a2 &amp; a1 | a3 &amp; (a2 | a1) return (a4, a5)def mix(a2, v16, a4): bits = [] for i in range(8): v4 = bit(a2, i) v5 = bit(v16, i) a4, a5 = _mix(v5, v4, a4) bits.insert(0, a5) return int(&apos;&apos;.join(map(str, bits)), 2), a4","categories":[{"name":"Welcome!","slug":"Welcome","permalink":"http://www.w4ter5heep.com/categories/Welcome/"}],"tags":[{"name":"MySite","slug":"MySite","permalink":"http://www.w4ter5heep.com/tags/MySite/"}]},{"title":"StarCTF-BabyDroid","slug":"StarCTF-BabyDroid","date":"2018-05-01T16:04:08.000Z","updated":"2018-05-01T16:30:24.660Z","comments":true,"path":"2018/05/02/StarCTF-BabyDroid/","link":"","permalink":"http://www.w4ter5heep.com/2018/05/02/StarCTF-BabyDroid/","excerpt":"","text":"逆向题目中唯一一道android逆向，做出来的过程也比较费力，这里简单记录。 安装程序发现会闪退，可能有反调试措施，首先进行静态分析。JEB查看Java代码部分： Alt text 关键方法是check0，同时注意到上面有许多check函数的native声明： Alt text 从so文件中查找相关方法。首先在liba.so中找到了check0函数：发现进一步调用的是check函数，但是在liba中没有相关信息，查找libb，没有直接找到check函数，考虑JNIOnLoad进行了注册，但是也没有找到JNIOnLoad函数，查找发现了sub_ED8函数： Alt text 对一部分数据进行了解密，同时发现了： Alt text Alt text 所以JNIOnLoad函数会在运行时才解密：解密的关键是这个值： Alt text 进入sub_9B4发现计算的应该是一个校验和，分析程序逻辑，写出计算校验和的脚本：1234567891011121314def crc32(ss): v2 = i32(-1) v7 = i32() for s in ss: if isinstance(s, bytes): s = s[0] for i in range(8): v7.value = v2.value ^ (s &gt;&gt; i &lt;&lt; 31) v2.value *= 2 if v7.value &lt;= -1: # if not 0x4C11DB7 &amp; 1: # v2.value ^= 1 v2.value ^= 0x4C11DB7 return u32(-v2.value).value - 1 得到libb的校验和：0x6674632a解密libb.so可以得到JNIOnLoad： Alt text 这里也进行了注册，将相关字符串进行解密可以发现就是对check函数的注册，解密脚本：1234567891011121314151617181920212223242526272829303132def xorstr(): def get_result(nums, key): nums = [[((i &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] for i in nums] # nums = sum(nums, []) nums = list(itertools.chain.from_iterable(nums)) nums = [i ^ key for i in itertools.takewhile(lambda i: i != 0, nums)] b = bytes(nums) return b nums = [0xBCFEFCF0, 0xEAE9A1E2, 0xF1F2F1BC, 0xF7FDF2EA, 0xF7FAFCE1, 0xFAF2DEBC, 0xE7F0D2FD, 0xE7FAE5FA, 0xea] print(get_result(nums, 0x93)) nums = [0x777C5A3E, 0x7A397760, 0x39717877, 0x7F646245, 0x3F2D7178, 0x4C] print(get_result(nums, 0x16)) nums = [0x73757873, 0x7B] print((get_result(nums, 0x10))) 解密结果为：com/q2zy/babyandroid/MainActivity (Ljava/lang/String;)Z check Alt text 即是注册的函数，但是发现依然是乱码，注意到下面还有一段解密： Alt text 这里用到了liba.so的校验和，计算发现也是0x6674632a解密得到check 函数： Alt text 再次用到了liba.so的校验和，分析逻辑写出解密脚本：1234567891011121314151617181920212223242526272829303132333435363738def get_flag(): crc = crc32(open(&apos;/Users/alset/Downloads/apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) crc2 = crc * crc checksums = [((crc2 &gt;&gt; (j * 8)) &amp; 0xff) for j in range(8)] b = bytearray([ 0xD5, 8, 0x4B, 0x11, 0xBF, 0xC, 0xB, 0x1F, 0xDC, 0x57, 0x64, 0x74, 0xB4, 0x6D, 0x5B, 0xD4, 0xEB, 0x1D, 0x51, 0xAE, 0xD5, 0x44, 8, # 0 ]) for i in range(8): for j in range(8): b[i + j] ^= checksums[j] i = 15 for j in range(8): b[i + j] ^= checksums[j] print(b) 得到flag：1nTr3stIng-AnDr0id-A&amp;D!完整解密脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import osimport mmapimport itertoolsfrom ctypes import c_int32 as i32, c_uint32 as u32def memory_map(filename, access=mmap.ACCESS_COPY): size = os.path.getsize(filename) fd = os.open(filename, os.O_RDWR) return mmap.mmap(fd, size, access=access)def crc32(ss): v2 = i32(-1) v7 = i32() for s in ss: if isinstance(s, bytes): s = s[0] for i in range(8): v7.value = v2.value ^ (s &gt;&gt; i &lt;&lt; 31) v2.value *= 2 if v7.value &lt;= -1: # if not 0x4C11DB7 &amp; 1: # v2.value ^= 1 v2.value ^= 0x4C11DB7 return u32(-v2.value).value - 1def recoverlibb(): m = memory_map(&apos;./apk/lib/armeabi-v7a/libb.so&apos;) start = 0xab8 size = 0x420 # right_asm = [0xf0, 0xb5, 0x3, 0xaf] # checksums = [m[start + i] ^ right_asm[i] for i in range(len(right_asm))] checksum = crc32(m) checksums = [((checksum &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] ichecksums = itertools.cycle(checksums) for i in range(size): m[start + i] = m[start + i] ^ next(ichecksums) start += 0x27C size -= 0x27C for i in range(0, , 4): m[start + i], m[start + i + 1], m[start + i + 2], m[start + i + 3] = m[start + i + 2], m[start + i + 3], m[ start + i], m[start + i + 1] # right_asm = [0xFF, 0xF7, 0x3E, 0xEE] # checksums = [m[start + size - 4 + i] ^ right_asm[i] for i in range(len(right_asm))] checksum = crc32(open(&apos;./apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) print(&apos;a: &apos;, checksum) checksums = [((checksum &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] ichecksums = itertools.cycle(checksums) for i in range(size): m[start + i] = m[start + i] ^ next(ichecksums) m.seek(0) open(&apos;./apk/lib/armeabi-v7a/libbnew2.so&apos;, &apos;wb&apos;).write(m.read())def xorstr(): def get_result(nums, key): nums = [[((i &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] for i in nums] # nums = sum(nums, []) nums = list(itertools.chain.from_iterable(nums)) nums = [i ^ key for i in itertools.takewhile(lambda i: i != 0, nums)] b = bytes(nums) return b nums = [0xBCFEFCF0, 0xEAE9A1E2, 0xF1F2F1BC, 0xF7FDF2EA, 0xF7FAFCE1, 0xFAF2DEBC, 0xE7F0D2FD, 0xE7FAE5FA, 0xea] print(get_result(nums, 0x93)) nums = [0x777C5A3E, 0x7A397760, 0x39717877, 0x7F646245, 0x3F2D7178, 0x4C] print(get_result(nums, 0x16)) nums = [0x73757873, 0x7B] print((get_result(nums, 0x10)))def get_flag(): crc = crc32(open(&apos;./apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) crc2 = crc * crc checksums = [((crc2 &gt;&gt; (j * 8)) &amp; 0xff) for j in range(8)] b = bytearray([ 0xD5, 8, 0x4B, 0x11, 0xBF, 0xC, 0xB, 0x1F, 0xDC, 0x57, 0x64, 0x74, 0xB4, 0x6D, 0x5B, 0xD4, 0xEB, 0x1D, 0x51, 0xAE, 0xD5, 0x44, 8, # 0 ]) for i in range(8): for j in range(8): b[i + j] ^= checksums[j] i = 15 for j in range(8): b[i + j] ^= checksums[j] print(b)if __name__ == &apos;__main__&apos;: # xorstr() # recoverlibb() get_flag()","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://www.w4ter5heep.com/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.w4ter5heep.com/tags/CTF/"},{"name":"Mobile","slug":"Mobile","permalink":"http://www.w4ter5heep.com/tags/Mobile/"}]},{"title":"hellow_my_site","slug":"hellow-my-site","date":"2018-04-05T09:19:55.000Z","updated":"2018-04-15T15:24:44.871Z","comments":true,"path":"2018/04/05/hellow-my-site/","link":"","permalink":"http://www.w4ter5heep.com/2018/04/05/hellow-my-site/","excerpt":"","text":"can you see my secret","categories":[{"name":"Welcome!","slug":"Welcome","permalink":"http://www.w4ter5heep.com/categories/Welcome/"}],"tags":[{"name":"MySite","slug":"MySite","permalink":"http://www.w4ter5heep.com/tags/MySite/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-04-05T02:35:01.800Z","updated":"2018-04-15T15:25:04.899Z","comments":true,"path":"2018/04/05/hello-world/","link":"","permalink":"http://www.w4ter5heep.com/2018/04/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Welcome!","slug":"Welcome","permalink":"http://www.w4ter5heep.com/categories/Welcome/"}],"tags":[{"name":"MySite","slug":"MySite","permalink":"http://www.w4ter5heep.com/tags/MySite/"}]}]}