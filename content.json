{"meta":{"title":"W4ter5heep's site","subtitle":null,"description":"Coding is fun!","author":"W4ter5heep","url":"http://www.w4ter5heep.com"},"pages":[{"title":"tags","date":"2018-04-06T01:29:00.000Z","updated":"2018-04-06T01:29:22.101Z","comments":true,"path":"tags/index.html","permalink":"http://www.w4ter5heep.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-06T01:09:53.000Z","updated":"2018-04-06T01:12:30.232Z","comments":true,"path":"categories/index.html","permalink":"http://www.w4ter5heep.com/categories/index.html","excerpt":"","text":""},{"title":"FriendLinks","date":"2018-04-06T01:48:23.000Z","updated":"2018-04-15T15:35:38.650Z","comments":true,"path":"friendlinks/index.html","permalink":"http://www.w4ter5heep.com/friendlinks/index.html","excerpt":"","text":"我我我最菜"}],"posts":[{"title":"看雪CTF——ExecuteTable","slug":"看雪CTF——ExecuteTable","date":"2018-07-03T01:53:04.697Z","updated":"2018-07-04T00:39:18.313Z","comments":true,"path":"2018/07/03/看雪CTF——ExecuteTable/","link":"","permalink":"http://www.w4ter5heep.com/2018/07/03/看雪CTF——ExecuteTable/","excerpt":"","text":"看雪CTF——ExecuteTable题目确实比较有难度，自己水平还是太差了，到了so文件的分析，根本不知道关键点在哪里 初步分析首先JEB分析java部分，可以看到有一些混淆，包括对字符串的base64加密等等，但是基本逻辑是可以看到的： -w315 主要需要进行两个函数的检测 第一个函数： 该函数要求输入的字符串中有特殊字符，但是该结果会被第二个函数的结果覆盖，因此并无实际用途 第二个函数为native函数，也是重点需要分析的so函数有诸多陷阱，包括反调试，热修改等等，做出来的方法也是各种骚操作，深深的无力感 = = so中的反调试，动态库在加载时会创建线程读取/proc/self/status中的TracerPid检测是否被调试 动态库被加载时会读取/proc/self/maps，获得自身基地址，然后通过分析程序头和.dynamic断，修改符号表，改变JNI_Onload地址。 动态库加载时，使用mprotect修改内存权限，使用自修改代码生成新的JNI_OnLoad 实际的解密程序中，有很多花指令和死循环，影响分析 md。。。想放弃 gdb动态调试，可以看到确实存在反调试： 断点可以下在JNI_OnLoad，但是该函数是被处理过的，需要解密 可以计算基地址：0xa909ae50-0x8204=0xa9092c4c但是感觉是不正确的. init_proc无实际用途 初始化函数数组函数 init_array找到so文件的0x34CD0位置，根据wp，可以知道是函数的初始化数组（wp似乎是通过修复so的section段发现的？不懂的操作）：可以通过readelf查看so文件的动态段得到init_array的地址 init_array先于JNI_OnLoad运行，上面的函数中应该存在对JNI_OnLoad的解密 sub_67bc ———— 创建反调试线程b8bc 可以看到这部分利用v8新开辟的0x20空间注册了函数某wp修复后的： 有几个函数比较关键：pthread_create，mprotect与__NR_openat应该下断点绕过反调试后进行分析的。。。但是不太会下断点 __NR_openat打开过/proc/self/maps与/proc/self/status, 而mprotect有修改JNI_OnLoad偏移与代码解密操作wp的推测：打开/proc/self/maps是为了拿到基址，/proc/self/status/是反调试, 后面实际解key时感觉应该是检测到调试，就把解密中需要用到的一个全局变量修改掉。导致得到错误的结果。mprotect调用了两次，第一次修改JNI_OnLoad的偏移，由0x8205修改为0xA260 ,这也就是真正的JNI_OnLoad函数，在这个函数中可以看到JNIEnv的FindClass与RegisterNatives，所以可以拿到验证key的native函数地址0xAC98直接去到0xAC98发现代码无法解析，应该是加密了。 所以第二次mprotect调用就是解密0xAC98中被加密的代码。 反调试线程b8bcsub_67bc下面用到的函数即是pthread_create，创建反调试线程 反调试部分的代码没有直接被ida识别为函数，可以create function得到 反调试的骚操作如下(中间有各种垃圾代码）： 解密字符串“tracePid”。 解密字符串“%*s%d”。 解密字符串“/proc/self/status”。 打开文件 “/proc/self/status”，一行一行读取，一直找到 “tracePid”为止。 调用scanf获取tracePid的数值。 如果 tracePid &gt; 0, 则全局变量0x36098 = 0xBD9813BA，否则 0x36098 = 0x2333AE83。 线程sleep 5秒。 过掉反调试： 0x36098 的值在对输入key进行变换时有用到，当程序处于调试状态时，会使key计算出错。过掉反调试方法很多，但是无论用啥方法必须要使0x36098 赋值为 0x2333AE83 。可以让线程进入死循环，或者让线程终止，或者让线程sleep(100000)秒，也可以直接修改逻辑让tracePid恒等于0。 真正JNI_OnLoad的获取和分析方法一：此函数不能直接下断点，否则可能会使代码解密失败，可以直接在libdvm中下断点。这个函数主要作用是动态注册native lkdakjudajndn函数 从这里可知 lkdakjudajndn函数地址为：AC98。这个函数是真正的key校验过程。 真正的JNI_OnLoad，没有代码的自解密，只是hook了地址，还比较友好可以查找注册lkdakjudajndn的位置： 并不知道是怎么计算得到函数lkdakjudajndn地址是0xAC98的，动态调试直接看？ check函数lkdakjudajndn 这部分代码是需要动态解密的，具体方法是调用mprotect进行解密，解密函数是sub_833c 函数混淆的也比较烦，很难分析，解密代码的主要部分 解密后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435char *__fastcall lkdakjudajndn(struct _JNIEnv *a1)&#123; char *inputKey; // r0 char *v2; // r4 unsigned int i; // r4 int v4; // r2 int v5; // r3 char v6; // r6 unsigned int j; // r4 int v8; // r2 int v9; // r3 char *v10; // r6 int v11; // r8 int v12; // r2 int v13; // r3 signed int v14; // r10 unsigned int v15; // r7 char v16; // r8 unsigned int keylen; // r2 int v18; // r2 int v19; // r3 int v20; // r2 int v21; // r3 unsigned int v22; // r7 unsigned int v23; // r8 int string_A3Cw6Gb0OZWPU52s_1; // ST10_4 int v25; // ST10_4 int lowkeyChar; // ST10_4 unsigned int string_3d8ahnb1_1; // r6 int v28; // r2 int v29; // r3 const char *v30; // r1 int v31; // r2 int v32; // r3 int v33; // r2 int v34; // r3 int v35; // r2 int v36; // r3 int *v37; // r0 int inputKeyString; // [sp+20h] [bp-6B8h] int newInputKeyBuf; // [sp+24h] [bp-6B4h] int inputKeyBuf; // [sp+28h] [bp-6B0h] int buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW; // [sp+2Ch] [bp-6ACh] _BYTE *string_3d8ahnb1_is_U8; // [sp+30h] [bp-6A8h] char buf_U8; // [sp+34h] [bp-6A4h] char string_3; // [sp+38h] [bp-6A0h] char buf_3w; // [sp+3Ch] [bp-69Ch] char buf_3ww; // [sp+40h] [bp-698h] char string_aA782e192b81nic; // [sp+44h] [bp-694h] char v49; // [sp+48h] [bp-690h] int string_A3Cw6Gb0OZWPU52s; // [sp+4Ch] [bp-68Ch] int string_0; // [sp+50h] [bp-688h] int string_0_1; // [sp+54h] [bp-684h] int v53; // [sp+58h] [bp-680h] char v54; // [sp+5Ch] [bp-67Ch] int newstring_BQ366EYdQs_1; // [sp+60h] [bp-678h] char buf_44678; // [sp+64h] [bp-674h] int string_A782E192B81NICAIsan38Qz; // [sp+68h] [bp-670h] char string_3373080; // [sp+6Ch] [bp-66Ch] int newstring_BQ366EYdQs; // [sp+70h] [bp-668h] char buf_29285; // [sp+74h] [bp-664h] char *v61; // [sp+78h] [bp-660h] char v62; // [sp+7Ch] [bp-65Ch] char string_BQ366EYdQs_1; // [sp+80h] [bp-658h] char string_BQ366EYdQs; // [sp+84h] [bp-654h] char newintputKey_buf; // [sp+88h] [bp-650h] char v66; // [sp+8Ch] [bp-64Ch] char v67; // [sp+90h] [bp-648h] int v68; // [sp+94h] [bp-644h] char v69; // [sp+98h] [bp-640h] char v70; // [sp+9Ch] [bp-63Ch] char input_KeyBuffer_location0; // [sp+A0h] [bp-638h] int inputKeyBuf_location1; // [sp+A4h] [bp-634h] char inputKeyBuf_last1; // [sp+A8h] [bp-630h] int string_UYetrq736UMayFindMe233; // [sp+ACh] [bp-62Ch] char buf_3d8ahnb1; // [sp+B0h] [bp-628h] char string_U8; // [sp+B4h] [bp-624h] char string_D; // [sp+B8h] [bp-620h] int buf_BQ366EYdQs3716UCANDOIT666; // [sp+BCh] [bp-61Ch] char string_0_2; // [sp+C0h] [bp-618h] char buf_BQ366EYdQs; // [sp+C4h] [bp-614h] int v81; // [sp+C8h] [bp-610h] char v82; // [sp+CCh] [bp-60Ch] char unknowStruct1; // [sp+D0h] [bp-608h] char string_1; // [sp+D8h] [bp-600h] int v85; // [sp+DCh] [bp-5FCh] char v86; // [sp+18Ch] [bp-54Ch] int v87; // [sp+194h] [bp-544h] char v88; // [sp+198h] [bp-540h] char v89; // [sp+248h] [bp-490h] char v90; // [sp+250h] [bp-488h] int v91; // [sp+254h] [bp-484h] char v92; // [sp+304h] [bp-3D4h] char v93; // [sp+30Ch] [bp-3CCh] char v94; // [sp+310h] [bp-3C8h] char v95; // [sp+3C0h] [bp-318h] char v96; // [sp+3C8h] [bp-310h] char v97; // [sp+3CCh] [bp-30Ch] char v98; // [sp+47Ch] [bp-25Ch] char v99; // [sp+484h] [bp-254h] char v100; // [sp+488h] [bp-250h] char buf_33687; // [sp+538h] [bp-1A0h] char v102; // [sp+540h] [bp-198h] char v103; // [sp+544h] [bp-194h] char string_DU8NABvA; // [sp+5F4h] [bp-E4h] int string_33687_0; // [sp+5FCh] [bp-DCh] int v106; // [sp+600h] [bp-D8h] inputKey = (char *)(*(int (**)(void))(*(_DWORD *)a1 + 676))(); newString1(&amp;inputKeyString, (int)inputKey); newString1(&amp;string_aA782e192b81nic, (int)&quot;A782E192B81NICAIsan38Qz&quot;); CreateUnknowStructFunc((int)&amp;unknowStruct1, 24); hextoString((int)&amp;string_1, 1); sub_DD44(&amp;v49, &amp;v85); v2 = (_BYTE *)(&amp;stru_908 + 10); if ( !std::operator==&lt;char&gt;(&amp;string_aA782e192b81nic, &amp;v49) ) v2 = (_BYTE *)(&amp;dword_0 + 1); if ( std::operator!=&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v49, &amp;string_aA782e192b81nic) ) &#123; CreateUnknowStructFunc((int)&amp;string_DU8NABvA, 24); hextoString((int)&amp;string_33687_0, 33687); sub_DD44(&amp;buf_33687, &amp;v106); v2 = (char *)std::operator==&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;buf_33687, &quot;0d87a&quot;); deleteString(&amp;buf_33687); sub_DBAC(&amp;string_DU8NABvA); &#125; if ( v2 == (_BYTE *)&amp;dword_0 + 1 ) v2 = (char *)off_35CFC + 303183; deleteString(&amp;v49); sub_DBAC(&amp;unknowStruct1); deleteString(&amp;string_aA782e192b81nic); if ( (unsigned int)(*(_DWORD *)(inputKeyString - 12) - 0xA) &lt;= 0xA )// key长度要小于等于20 &#123; GetStringBuf(&amp;inputKeyBuf, &amp;inputKeyString);// inputKeyBuf = C0ngRa7U1AtIoN2U newString1(&amp;newInputKeyBuf, (int)&amp;unk_30735); copyStringFromLocation((int)&amp;inputKeyBuf_location1, &amp;inputKeyBuf, 1u, *(_DWORD *)(inputKeyBuf - 12)); copyStringFromLocation((int)&amp;input_KeyBuffer_location0, &amp;inputKeyBuf, 0, 1u); stringStrCat(&amp;inputKeyBuf_last1, &amp;inputKeyBuf_location1, (int)&amp;input_KeyBuffer_location0);// 将第一个字符放到最后一个位置上 StringChange((int)&amp;inputKeyBuf, (int)&amp;inputKeyBuf_last1);// inputKeyBuf=inputKeyBuf_last1 deleteString(&amp;inputKeyBuf_last1); deleteString(&amp;input_KeyBuffer_location0); deleteString(&amp;inputKeyBuf_location1); // inputKeyBuf = 0ngRa7U1AtIoN2UC for ( i = 0; i &lt; *(_DWORD *)(inputKeyBuf - 12); ++i )// 根据输入的key进行从字典中索引然后创建新的字符串 CreateStringByChar(&amp;newInputKeyBuf, *((_BYTE *)off_35CF8 + *(unsigned __int8 *)(inputKeyBuf + i) + 0x21)); StringChange((int)&amp;inputKeyBuf, (int)&amp;newInputKeyBuf);// 此时 inputKeyBuf变成新的了 SetStringNull((int)&amp;newInputKeyBuf, (int)&amp;unk_30735, v4, v5);// 此时81 bb b1 70 c9 d8 64 41 ad 4f c4 bd e2 19 64 11 newString1(&amp;newstring_BQ366EYdQs, (int)&quot;BQ366EYdQs3716UCANDOIT666&quot;); CreateUnknowStructFunc((int)&amp;v95, 24); hextoString((int)&amp;v96, 29285); sub_DD44(&amp;buf_29285, &amp;v97); copyStringFromLocation((int)&amp;string_BQ366EYdQs, &amp;newstring_BQ366EYdQs, 0, 0xAu); StringChange((int)&amp;newstring_BQ366EYdQs, (int)&amp;string_BQ366EYdQs);// 变成10个了 deleteString(&amp;string_BQ366EYdQs); if ( std::operator==&lt;char&gt;(&amp;newstring_BQ366EYdQs, &amp;buf_29285) ) v6 = 50; else v6 = 1; deleteString(&amp;buf_29285); sub_DBAC(&amp;v95); deleteString(&amp;newstring_BQ366EYdQs); for ( j = 0; j &lt; *(_DWORD *)(inputKeyBuf - 12); ++j ) CreateStringByChar( // 进行低4位和高位的切换，并且创建新的string &amp;newInputKeyBuf, ((*(_BYTE *)(inputKeyBuf + j) &amp; 0xF) &lt;&lt; 4 * v6) | (*(_BYTE *)(inputKeyBuf + j) &gt;&gt; 4)); StringChange((int)&amp;inputKeyBuf, (int)&amp;newInputKeyBuf);// 此时inputKey每个字节的低4位和高4位进行切换了 // 此时18 bb 1b 07 9c 8d 46 14 da f4 4c db 2e 91 46 11 SetStringNull((int)&amp;newInputKeyBuf, (int)&amp;unk_30735, v8, v9); newString1(&amp;string_A782E192B81NICAIsan38Qz, (int)&quot;A782E192B81NICAIsan38Qz&quot;); CreateUnknowStructFunc((int)&amp;v92, 24); hextoString((int)&amp;v93, 3373080); sub_DD44(&amp;string_3373080, &amp;v94); v10 = (char *)3373029; if ( !std::operator==&lt;char&gt;(&amp;string_A782E192B81NICAIsan38Qz, &amp;string_3373080) ) v10 = (char *)3373080; if ( std::operator!=&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;( &amp;string_3373080, &amp;string_A782E192B81NICAIsan38Qz) ) &#123; CreateUnknowStructFunc((int)&amp;string_DU8NABvA, 24); hextoString((int)&amp;string_33687_0, 33687); sub_DD44(&amp;buf_33687, &amp;v106); v10 = (char *)std::operator==&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;buf_33687, &quot;0d87a&quot;); deleteString(&amp;buf_33687); sub_DBAC(&amp;string_DU8NABvA); if ( v10 ) v10 = (char *)off_35CFC + 0x4A04F; &#125; deleteString(&amp;string_3373080); sub_DBAC(&amp;v92); deleteString(&amp;string_A782E192B81NICAIsan38Qz);// 对输入的key4字节与 DA78DE8A进行亦或 v11 = 0; do // 0x36090 &#123; // // 36098 = DA78DE8A CreateStringByChar(&amp;newInputKeyBuf, v10[inputKeyBuf + v11] ^ dword_36098); CreateStringByChar(&amp;newInputKeyBuf, BYTE1(dword_36098) ^ *(_BYTE *)(inputKeyBuf + v11 + 1)); CreateStringByChar(&amp;newInputKeyBuf, BYTE2(dword_36098) ^ *(_BYTE *)(inputKeyBuf + v11 + 2)); CreateStringByChar(&amp;newInputKeyBuf, *(_BYTE *)(inputKeyBuf + v11 + 3) ^ HIBYTE(dword_36098)); v11 += 4; &#125; while ( v11 != 0x10 ); // 证明输入的key为16个字节 StringChange((int)&amp;inputKeyBuf, (int)&amp;newInputKeyBuf); SetStringNull((int)&amp;newInputKeyBuf, (int)&amp;unk_30735, v12, v13); newString1(&amp;newstring_BQ366EYdQs_1, (int)&quot;BQ366EYdQs3716UCANDOIT666&quot;); CreateUnknowStructFunc((int)&amp;v89, 24); hextoString((int)&amp;v90, 44678); sub_DD44(&amp;buf_44678, &amp;v91); copyStringFromLocation((int)&amp;string_BQ366EYdQs_1, &amp;newstring_BQ366EYdQs_1, 0, 0xAu); StringChange((int)&amp;newstring_BQ366EYdQs_1, (int)&amp;string_BQ366EYdQs_1); deleteString(&amp;string_BQ366EYdQs_1); if ( std::operator==&lt;char&gt;(&amp;newstring_BQ366EYdQs_1, &amp;buf_44678) ) v14 = 50; else v14 = 1; deleteString(&amp;buf_44678); sub_DBAC(&amp;v89); v15 = 0; deleteString(&amp;newstring_BQ366EYdQs_1); // 此时key =9b 15 28 24 1f 23 75 37 59 5a 7f f8 ad 3f 75 32 while ( 1 ) &#123; // 对输入key进行相邻字节交换 keylen = *(_DWORD *)(inputKeyBuf - 12); if ( v15 &gt;= keylen &gt;&gt; 1 ) break; v16 = *(_BYTE *)(inputKeyBuf + 2 * v15); CreateStringByChar(&amp;newInputKeyBuf, *(_BYTE *)(inputKeyBuf + v14 + 2 * v15)); CreateStringByChar(&amp;newInputKeyBuf, v16); ++v15; &#125; if ( keylen &amp; 1 ) &#123; copyStringFromLocation((int)&amp;v70, &amp;inputKeyBuf, keylen - 1, 1u); copyString((int)&amp;newInputKeyBuf, (int)&amp;v70); deleteString(&amp;v70); &#125; StringChange((int)&amp;inputKeyBuf, (int)&amp;newInputKeyBuf);// 此时key进行了相邻字节交换 // 此时15 9b 24 28 23 1f 37 75 5a 59 f8 7f 3f ad 32 75 // SetStringNull((int)&amp;newInputKeyBuf, (int)&amp;unk_30735, v18, v19); while ( (unsigned int)v10 &lt; *(_DWORD *)(inputKeyBuf - 12) )// 再次对字典7FC2开始索引 CreateStringByChar(&amp;newInputKeyBuf, *((_BYTE *)off_35CF8 + (unsigned __int8)(v10++)[inputKeyBuf] + 33)); StringChange((int)&amp;inputKeyBuf, (int)&amp;newInputKeyBuf);// inputKeyBuf= 33 1a 3c 38 1e c7 d8 1b 37 83 05 a5 54 1d 19 1b SetStringNull((int)&amp;newInputKeyBuf, (int)&amp;unk_30735, v20, v21); newString1(&amp;v53, (int)&quot;BQ366EYdQs3716UCANDOIT666&quot;); CreateUnknowStructFunc((int)&amp;v86, 24); hextoString((int)&amp;v87, 154634026); sub_DD44(&amp;v54, &amp;v88); copyStringFromLocation((int)&amp;v62, &amp;v53, 0, 0xAu); StringChange((int)&amp;v53, (int)&amp;v62); deleteString(&amp;v62); if ( std::operator==&lt;char&gt;(&amp;v53, &amp;v54) ) v22 = 50; else v22 = 1; // v22=1 deleteString(&amp;v54); sub_DBAC(&amp;v86); deleteString(&amp;v53); copyStringFromLocation((int)&amp;v68, &amp;inputKeyBuf, v22, *(_DWORD *)(inputKeyBuf - 12)); copyStringFromLocation((int)&amp;v67, &amp;inputKeyBuf, 0, v22); stringStrCat(&amp;v69, &amp;v68, (int)&amp;v67); StringChange((int)&amp;newInputKeyBuf, (int)&amp;v69);// 此时 newintputKey_buf 第一个字节被置换到最后一个字节 // 1a 3c 38 1e c7 d8 1b 37 83 05 a5 54 1d 19 1b 33 deleteString(&amp;v69); deleteString(&amp;v67); deleteString(&amp;v68); GetStringBuf(&amp;newintputKey_buf, &amp;newInputKeyBuf); newString1(&amp;string_A3Cw6Gb0OZWPU52s, (int)&quot;A3Cw6Gb0OZWPU52s&quot;); newString1(&amp;string_0, (int)&amp;unk_30735); newString1(&amp;string_0_1, (int)&amp;unk_30735); v23 = 0; while ( v23 &lt; *(_DWORD *)(*(_DWORD *)&amp;newintputKey_buf - 12) )// 此时 newintputKey_buf = 13 3b 39 1d c4 d5 15 33 87 0b a8 57 1e 18 1c 3a &#123; // string_0放A3Cw6Gb0OZWPU52s按照高4位索引的string // string_1放A3Cw6Gb0OZWPU52s按照低位索引的string string_A3Cw6Gb0OZWPU52s_1 = string_A3Cw6Gb0OZWPU52s; sub_191A8(&amp;newintputKey_buf); CreateStringByChar( // 将输入key按字节/16 然后从A3Cw6Gb0OZWPU52s中按照索引获取 &amp;string_0, *(_BYTE *)(string_A3Cw6Gb0OZWPU52s_1 + ((unsigned int)*(unsigned __int8 *)(*(_DWORD *)&amp;newintputKey_buf + v23) &gt;&gt; 4))); v25 = string_A3Cw6Gb0OZWPU52s; sub_191A8(&amp;newintputKey_buf); lowkeyChar = *(unsigned __int8 *)(v25 + (*(_BYTE *)(*(_DWORD *)&amp;newintputKey_buf + v23) &amp; 0xF));// 然后字节&amp;0xF 再从A3Cw6Gb0OZWPU52s中索引 v61 = (char *)off_35D04 + 12; createStringByLen((int *)&amp;v61, *(_DWORD *)(string_0_1 - 12) + 1); sub_19520((int *)&amp;v61, 1u, lowkeyChar); sub_193C4((int *)&amp;v61, (_BYTE **)&amp;string_0_1); StringChange((int)&amp;string_0_1, (int)&amp;v61); ++v23; deleteString(&amp;v61); &#125; stringStrCat(&amp;v66, &amp;string_0, (int)&amp;string_0_1);// 高位4位与第4位分别索引获取的子串 // 3ww3U53wOAWG333wWUO20OP0wGG65ZPw // // 这个应该是真实的 // 3ww3U53wOAWG333wwPZ56GGw0PO02OUW // 3ww3U53wOAWG333wwPZ56GGw0PO02OUW deleteString(&amp;string_0_1); deleteString(&amp;string_0); deleteString(&amp;string_A3Cw6Gb0OZWPU52s); StringChange((int)&amp;newInputKeyBuf, (int)&amp;v66);// inputkey变成了高位索引和低位索引的string了 deleteString(&amp;v66); deleteString(&amp;newintputKey_buf); deleteString(&amp;inputKeyBuf); newString1(&amp;string_3d8ahnb1_is_U8, (int)&quot;3d8ahnb1&quot;); newString1(&amp;string_UYetrq736UMayFindMe233, (int)&quot;UYetrq736UMayFindMe233&quot;); CreateUnknowStructFunc((int)&amp;v98, 24); sub_F0A4((int)&amp;v99, &amp;string_3d8ahnb1_is_U8); sub_DD44(&amp;buf_3d8ahnb1, &amp;v100); sub_191A8(&amp;string_3d8ahnb1_is_U8); string_3d8ahnb1_1 = (unsigned __int8)*string_3d8ahnb1_is_U8; if ( std::operator==&lt;char&gt;(&amp;string_UYetrq736UMayFindMe233, &amp;buf_3d8ahnb1) )// 不等 &#123; newString1(&amp;string_DU8NABvA, (int)&quot;DABD786ABH&quot;); if ( string_3d8ahnb1_1 == 1 ) &#123; v30 = &quot;8a7d9Vduya&quot;; &#125; else if ( string_3d8ahnb1_1 &gt;= 1 ) &#123; if ( string_3d8ahnb1_1 == 2 ) v30 = &quot;73812huvVQ&quot;; else v30 = &quot;daj87YBDASYBvy&quot;; &#125; else &#123; v30 = &quot;UDHA47DBsd&quot;; &#125; SetStringNull((int)&amp;string_3d8ahnb1_is_U8, (int)v30, v28, v29); copyString((int)&amp;string_3d8ahnb1_is_U8, (int)&amp;string_DU8NABvA); deleteString(&amp;string_DU8NABvA); &#125; if ( std::operator!=&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;( &amp;string_UYetrq736UMayFindMe233, &amp;buf_3d8ahnb1) ) &#123; SetStringNull((int)&amp;string_3d8ahnb1_is_U8, (int)&amp;unk_30735, v31, v32);// 进来 newString1(&amp;string_DU8NABvA, (int)&quot;DU8NABvA&quot;); copyStringFromLocation((int)&amp;string_D, &amp;string_DU8NABvA, 0, 1u); copyString((int)&amp;string_3d8ahnb1_is_U8, (int)&amp;string_D); deleteString(&amp;string_D); if ( std::operator!=&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;string_3d8ahnb1_is_U8, &amp;unk_30735) ) SetStringNull((int)&amp;string_3d8ahnb1_is_U8, (int)&amp;unk_30735, v33, v34);// 又变成空了 copyStringFromLocation((int)&amp;string_U8, &amp;string_DU8NABvA, 1u, 2u); copyString((int)&amp;string_3d8ahnb1_is_U8, (int)&amp;string_U8);// 又变成U8了 deleteString(&amp;string_U8); if ( std::operator!=&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;string_3d8ahnb1_is_U8, &amp;unk_30735) ) SetStringNull((int)&amp;string_3d8ahnb1_is_U8, (int)&amp;unk_30735, v35, v36);// 又设置成空了 deleteString(&amp;string_DU8NABvA); &#125; GetStringBuf(&amp;buf_U8, (int *)&amp;string_3d8ahnb1_is_U8);// 到这里了 deleteString(&amp;buf_3d8ahnb1); sub_DBAC(&amp;v98); deleteString(&amp;string_UYetrq736UMayFindMe233); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;string_3, &amp;buf_U8, &apos;3&apos;); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;buf_3w, &amp;string_3, &apos;w&apos;); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;buf_3ww, &amp;buf_3w, &apos;w&apos;); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;( &amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &amp;buf_3ww, &apos;3&apos;); deleteString(&amp;buf_3ww); deleteString(&amp;buf_3w); deleteString(&amp;string_3); deleteString(&amp;buf_U8); deleteString(&amp;string_3d8ahnb1_is_U8); if ( std::operator!=&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;( &amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &amp;unk_30735) ) &#123; sub_19504(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &quot;U5&quot;); CreateStringByChar(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &apos;3&apos;); CreateStringByChar(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &apos;w&apos;); &#125; if ( *(_DWORD *)(buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW - 12) ) &#123; sub_19504(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &quot;OAWG&quot;); CreateStringByChar(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &apos;3&apos;); CreateStringByChar(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &apos;3&apos;); CreateStringByChar(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &apos;3&apos;); &#125; CreateStringByChar(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, 119); CreateStringByChar(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, 119); sub_19504(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW, &quot;PZ56GGw0PO02OUW&quot;); if ( std::operator==&lt;char&gt;(&amp;newInputKeyBuf, &amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW) &amp;&amp; *(_DWORD *)(inputKeyString - 12) == 16 ) &#123; newString1(&amp;buf_BQ366EYdQs3716UCANDOIT666, (int)&quot;BQ366EYdQs3716UCANDOIT666&quot;); CreateUnknowStructFunc((int)&amp;string_DU8NABvA, 24); hextoString((int)&amp;string_33687_0, 0); sub_DD44(&amp;string_0_2, &amp;v106); copyStringFromLocation((int)&amp;buf_BQ366EYdQs, &amp;buf_BQ366EYdQs3716UCANDOIT666, 0, 0xAu); StringChange((int)&amp;buf_BQ366EYdQs3716UCANDOIT666, (int)&amp;buf_BQ366EYdQs); deleteString(&amp;buf_BQ366EYdQs); if ( std::operator==&lt;char&gt;(&amp;buf_BQ366EYdQs3716UCANDOIT666, &amp;string_0_2) ) v2 = (char *)&amp;word_32; else v2 = (_BYTE *)(&amp;dword_0 + 1); deleteString(&amp;string_0_2); sub_DBAC(&amp;string_DU8NABvA); v37 = &amp;buf_BQ366EYdQs3716UCANDOIT666; &#125; else &#123; newString1(&amp;v81, (int)&quot;A782E192B81NICAIsan38Qz&quot;); CreateUnknowStructFunc((int)&amp;buf_33687, 24); hextoString((int)&amp;v102, 1); sub_DD44(&amp;v82, &amp;v103); v2 = (_BYTE *)(&amp;stru_908 + 10); if ( !std::operator==&lt;char&gt;(&amp;v81, &amp;v82) ) v2 = (_BYTE *)(&amp;dword_0 + 1); if ( std::operator!=&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v82, &amp;v81) ) &#123; CreateUnknowStructFunc((int)&amp;string_DU8NABvA, 24); hextoString((int)&amp;string_33687_0, 33687); sub_DD44(&amp;v98, &amp;v106); v2 = (char *)std::operator==&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v98, &quot;0d87a&quot;); deleteString(&amp;v98); sub_DBAC(&amp;string_DU8NABvA); &#125; if ( v2 == (_BYTE *)&amp;dword_0 + 1 ) v2 = (char *)off_35CFC + 303183; deleteString(&amp;v82); sub_DBAC(&amp;buf_33687); v37 = &amp;v81; &#125; deleteString(v37); deleteString(&amp;buf_3ww3U53wOAWG333wwPZ56GGw0PO02OUW); deleteString(&amp;newInputKeyBuf); &#125; deleteString(&amp;inputKeyString); return v2;&#125; 花指令里面有一些花指令如下： 1234if ( ((int (__fastcall *)(int *, char *))operator_equal)(&amp;v63, &amp;v64) ) v4 = 50; else v4 = 1; 结尾的指令用于产生一个常量1。而： 12if ( v4 == 1 ) v4 = -1865641388; 还有一些产生了一个字符串，然后if(串非空)将串置空;这样的花指令。 check的主要操作函数的主要操作如下： 将输入key的jstring对象转换成 cstring对象 。 key长度必须大于等于10，小于等于20。 将输入key置换到最后一位，变成key_change1。 索引 索引 0x7FC2 ，key_change2[i] = 0x7FC2[ key_change1[i]]，得到 key_change2。 将 key_change2按照字节进行低4位与高四位的置换生成 key_change3。 将 key_change3以4字节形式与 0x36098内容进行异或，当处于调试状态是其值为 0xBD9813BA，否则为 0x2333AE83。得到 key_change4,从这里可知key长度为0x10。 将 key_change4相邻2字节交换，得到 key_change5 ，即 key_change5[2i] = key_change4[2i+1] key_change5[2i + 1] = key_change4[2i]。 再次 索引7FC2 ，key_change6[i] = 7FC2[ key_change5 [i]]， 得到 key_change6。 将 key_change6的第一字符置换到最后位置，得到 key_change7。 将 key_change7的所有字符的高4位对字符串“A3Cw6Gb0OZWPU52s ”进行索引，组成 key_change8_highString, 将 key_change7所有字符的低4位对字符串“A3Cw6Gb0OZWPU52s”进行索引，并进行倒序。组成 key_change8_lowString, 然后将 key_change8_highString与 key_change8_lowString进行拼接生成 key_change8 生成字符串“3ww3U53wOAWG333wwPZ56GGw0PO02OUW”。 将 key_change8 与 “3ww3U53wOAWG333wwPZ56GGw0PO02OUW”比较，相等返回1，否则返回其他。 wp的其中一种解密代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109def calc1(input): l = input[:-1] l.insert(0, input[-1]) r = [chr(i) for i in l] print (&apos;[+] calc1: &apos;, r) def calc2(table, input): r1 = [] for i in input: for j in range(0, len(table)): if i == table[j]: r1.append(j) print (&apos;[+] calc2: &apos;, r1) return r1 def calc3(input): r1 = [] for i in input: r1.append(((i &gt;&gt; 4) &amp; 0xF) + ((i &amp; 0xF) &lt;&lt; 4)) print (&apos;[+] calc3: &apos;, r1) return r1 def calc4(table, input): r1 = [] n = 0 for i in input: if n == 4: n = 0 r1.append(i ^ table[n]) n += 1 print (&apos;[+] calc4: &apos;, r1) return r1 def calc5(input): for i in range(0, len(input), 2): if i % 2 == 0: tmp = input[i+1] input[i+1] = input[i] input[i] = tmp print (&apos;[+] calc5: &apos;, input) return input def calc6(table, input): r1 = [] for i in input: for j in range(0, len(table)): if i == table[j]: r1.append(j) print (&apos;[+] calc6: &apos;, r1) return r1 def calc7(table, s1, s2): r1 = [] for i in s1: for j in range(0, len(table)): if table[j] == i: r1.append(j &lt;&lt; 4) n = 0 for i in s2: for j in range(0, len(table)): if table[j] == i: r1[n] = r1[n] + j n += 1 print (&apos;[+] calc7: &apos;, r1) return r1 def calc8(input): s1 = input[:15] s1 = input[16] + s1 tmp = input[:15:-1] s2 = input[16] + tmp[:15] print (&apos;[+] calc8:&apos;, s1, s2) return s1, s2 if __name__ == &apos;__main__&apos;: mainTable = [0x40, 0x50, 0x78, 0x7A, 0x29, 0x88, 0xF7, 0x06, 0x21, 0x09, 0xF3, 0x5C, 0x95, 0xAE, 0x66, 0x12,0x8F, 0x85, 0xC8, 0x5A, 0xBF, 0x33, 0x3D, 0x86, 0x90, 0x8C, 0xED, 0xD5, 0x8B, 0xA4, 0xC5, 0xC7,0xEA, 0xF6, 0x79, 0x1E, 0x3C, 0xBA, 0x97, 0x4E, 0x38, 0x60, 0x08, 0xDD, 0xFA, 0xB3, 0xDE, 0x77,0x81, 0x41, 0x19, 0xF4, 0x52, 0x6B, 0xFF, 0xD8, 0x2A, 0xC2, 0xBC, 0xB9, 0xE7, 0x91, 0xE9, 0x54,0x82, 0xAD, 0x7E, 0x11, 0x35, 0x93, 0xB0, 0xA1, 0x18, 0xC4, 0x53, 0x0A, 0x74, 0x2F, 0xE2, 0x17,0x98, 0x0C, 0x70, 0x92, 0x47, 0x64, 0x16, 0xFE, 0x75, 0x83, 0x37, 0x8D, 0x07, 0x72, 0x25, 0x04,0xB7, 0xC9, 0xCE, 0x0E, 0x9E, 0xEB, 0xCF, 0xB1, 0xDB, 0x71, 0x56, 0xAF, 0x39, 0xF0, 0xBB, 0xBD,0x46, 0x32, 0xE6, 0x9F, 0x4F, 0x1B, 0x4D, 0x68, 0xF2, 0x4B, 0x2E, 0xCB, 0x20, 0xD2, 0x0B, 0xA5,0xEE, 0xE1, 0xA9, 0x2B, 0x84, 0x14, 0x67, 0x63, 0x6F, 0x3E, 0x7F, 0xFD, 0xB6, 0xFC, 0x55, 0x7C,0x5F, 0xF8, 0x4C, 0x65, 0x2C, 0x30, 0xEF, 0x48, 0xD7, 0x0D, 0x0F, 0x1A, 0x5E, 0xC0, 0x3A, 0x57,0x6A, 0x31, 0x00, 0xF1, 0x59, 0x10, 0xB8, 0x9A, 0x43, 0x73, 0xA3, 0x6E, 0x26, 0x1D, 0x13, 0x15,0x89, 0x5D, 0xDA, 0x61, 0xD1, 0x6C, 0xD3, 0xE0, 0xD9, 0x1F, 0xD4, 0x49, 0xEC, 0xE3, 0xD0, 0x34,0x36, 0xC6, 0x24, 0xE4, 0xF5, 0xAA, 0x9B, 0xB2, 0x4A, 0xDF, 0xAC, 0x96, 0xDC, 0xE8, 0xA0, 0xF9,0xC1, 0x9C, 0xCA, 0x9D, 0x27, 0xC3, 0xBE, 0x87, 0x28, 0xCC, 0x99, 0xE5, 0x45, 0x58, 0x94, 0x23,0x22, 0xFB, 0x02, 0x01, 0x03, 0x8A, 0x7B, 0xB5, 0x1C, 0xA7, 0x44, 0xCD, 0xA2, 0x51, 0x8E, 0x3F,0x42, 0xD6, 0x69, 0xAB, 0x62, 0x3B, 0x7D, 0xA6, 0x05, 0x2D, 0xA8, 0x80, 0x6D, 0xB4, 0x76, 0x5B] table = [&apos;A&apos;, &apos;3&apos;, &apos;C&apos;, &apos;w&apos;, &apos;6&apos;, &apos;G&apos;, &apos;b&apos;, &apos;0&apos;, &apos;O&apos;, &apos;Z&apos;, &apos;W&apos;, &apos;P&apos;, &apos;U&apos;, &apos;5&apos;, &apos;2&apos;, &apos;s&apos;] txor = [0x83, 0xAE, 0x33, 0x23] s1, s2 = calc8(&apos;3ww3U53wOAWG333wwPZ56GGw0PO02OUW&apos;) key1 = calc7(table, s1, s2) key2 = calc6(mainTable, key1) key3 = calc5(key2) key4 = calc4(txor, key3) key5 = calc3(key4) key6 = calc2(mainTable, key5) calc1(key6)","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://www.w4ter5heep.com/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.w4ter5heep.com/tags/CTF/"},{"name":"Android","slug":"Android","permalink":"http://www.w4ter5heep.com/tags/Android/"}]},{"title":"SUCTF复盘——三个RE","slug":"SUCTF复盘——三个RE","date":"2018-06-04T13:01:02.000Z","updated":"2018-07-04T00:20:25.776Z","comments":true,"path":"2018/06/04/SUCTF复盘——三个RE/","link":"","permalink":"http://www.w4ter5heep.com/2018/06/04/SUCTF复盘——三个RE/","excerpt":"","text":"RoughLike与期末大作业.Net逆向首先承认，比赛的时候因为手比较快下载的是有img文件夹的压缩包，但是很迷，上午提交截图的flag提示错误，下午就对了。。。 更新后题目的目录结构如下： 可以发现dll文件非常大，反倒是主程序比较小在test_Data中找到比较多的文件但好像运行报错？ 还要改文件夹名字。。。 hint提示要看过场动画首先可以看到开始的过场动画： 说明flag有两段？有点牵强。。。 尝试玩了几关，没什么发现，并且动作缓慢 得到第二段flag的一种方法：查看Data文件夹中的level1文件，使用010editor直接搜索字符串，找到： 得到第二段flag：_70_5uc7F有点不讲道理 得到第一段flag方法：首先要知道Managed文件夹中Dotfuscated是因为对.NET进行了混淆：使用De4dot对Dotfuscated的Assembly-CSharp.dll进行去混淆，该工具在吾爱破解工具包中就有。然后使用.NET Reflator进行反编译，搜索关键词找到关键函数： 有两个decrypt函数： 内容： 满足这两个条件即会在地图上随机位置生成一个flag，但是条件比较苛刻：12&lt;&lt;8|12&gt;&gt;0x18目测是一个很大的数第二个也同样 可以通过修改初始参数值使条件满足，但是这里想办法分析函数：这里要查找S3cretArray数组初始化的位置是LoadBundle： 继续追踪到解密函数：DecryptAssetBundle( 前几天刚做了一个题，目测是索引表变了以后的base64 要解密的文件是： 解密脚本：12345678910111213141516171819202122import stringimport base64 custom = &quot;QRSTUVWXYZABCDEFGHIJKLMNOPabcdefghijklmnopqrstuvwxyz0123456789+/&quot;standard= &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; plainText=&quot;GetProcAddr&quot; def decryptbundle(pathname,dst): decode=&quot;&quot; with open(&quot;/Users/ilan/Desktop/SUCTF/re/Output/test_Data/StreamingAssets/bundles/%s&quot;%(pathname),&quot;rb&quot;) as f: encode=f.read() for ch in encode: if(ch in custom): decode=decode+standard[string.find(custom,str(ch))] elif(ch == &apos;=&apos;): decode= decode+&apos;=&apos; decode=base64.b64decode(decode) with open(dst,&quot;wb&quot;) as f: f.write(decode) decryptbundle(&quot;WeaponYourself.assetbundle&quot;,&quot;ext1&quot;) 此时对解密后的文件进行解析即可：利用工具解析文件，中间需要经过一步解压缩，搜索二进制文件的“flag”可以得到： 第一部分flag的base64也可以使用python的第三方库解压读取文件内容：https://github.com/HearthSim/UnityPack 在此基础上，可以通过分析代码的方式找到前半段Flag：在场景初始化函数中找到： 满足判断条件会设置为True条件为满足关卡数目和99整除且defeatedBoss数量大于0x72000000且defeatedMonster大于514时，会设置一个文本SPText标志位为true。 不可能完成的任务 因此可以直接设置SPText标志为True： 然后重新进入游戏就会直接显示flag了 官方的wp比较简单，通过修改程序执行逻辑使flag可以在程序运行时就显示flag以及相关道具 simpleformat就是一个printf输出格式化的问题程序逻辑比较简单： 需要输入36个字符，主要变换在sub_4006F6函数，然后将数据写入了/dev/null该函数比较恶心，有一大堆的dprintf 分析这一大堆奇怪的字符串，可以发现一些规律：格式基本类似于%1$*2$s，每个函数中字符串的结尾都是%20$n首先要知道参数的用法：%n指的是向任意地址写入任意值，作用是将之前输出的字符个数写入对应的参数指向的地址printf的$的用法则是指定这个格式串解析的参数偏移量。%2$s即为取出后面的第2个参数，以%s的形式输出。因此%20$n就是将之前输出的字符个数写到第20个参数的地址里。即unk_627200用于计数，因此每个dprintf最后第20个参数都是一个int数组中的元素，并且是用于memcmp的比较接下来就是每次写入的字符数量是如何获得的，分析%1$*2$s格式的含义*有指定宽度的效果，宽度取自后面的参数，%1$*2$s就是将第一个参数以第二个参数的宽度输出当输出%1$*2$s的串之后，当前输出长度即为第二个参数。继续遇到%1$*2$s则再次输出第二个参数长度，当前输出长度就变成了两倍第二个参数，最后会将输出总长度写入unk_627200因此起到了一个求和的效果：n1l1 + n2l3 + …… + n19*l19 = m1······总共18个方程，18元一次方程组大佬的脚本：123456789101112131415161718192021222324252627282930313233343536373839from zio import *from z3 import *formats = [] #数据太多太长给删掉了。。。可以自己补results = [5462280L, 4346506L, 5891159L, 6839864L, 7912833L, 7049790L, 7455784L, 7311612L, 6299256L, 7114100L, 7037043L, 6873051L, 5644794L, 8014197L, 6432215L, 6638450L, 6959905L, 6705884L]print len(formats)print len(results)s = Solver()d = [BitVec(&quot;d&#123;0&#125;&quot;.format(i), 16) for i in range(18)]for j in range(len(formats)): fmt = formats[j] left = 0 left_str = &apos;&apos; for i in range(2, 20): c = &apos;%1$*&apos;+str(i)+&apos;$s&apos; left += fmt.count(c)*d[i-2] #left_str += str(fmt.count(c))+&apos;*d[&apos;+str(i-2)+&apos;] + &apos; #print left_str s.add(left == results[j])print s.check()print s.model()model = s.model()init_state = &#123;&#125;for k in model: idx = int(str(k)[1:]) val = model[k].as_long() #print idx, val init_state[idx] = valflag = &apos;&apos;for i in range(18): flag += l16(init_state[i])print flag 注意细节，flag每两位作为了一个数伏地膜 enigma即二战时德国所使用的转轮密码机简单查看了密码机的原理，实际上enigma采用复式字母替换加密方法，利用键盘、转子、跳线、反射板、显示器进行对称加密/解密。Enigma属于算法和密钥分离的加密方法，破解Enigma的难度在于不知道当前密钥，包括转子的初始位置和跳线设置。 查找关键函数，根据官方wp，程序实现了转轮机，线性反馈移位寄存器，换位器等输入： 长度要求是36最后经过比较要相等： 中间三个处理函数： sub_124F 单个取输入字符进行处理，然后写入最后用于比较的outstr sub_F1E sub_11F0 因此对于输入的处理都是线性的，有爆破的可能断点下在： 然后对存储结果处的数据进行比较： 这是比较取巧的方法，需要自动调用gdb 出题人的本意是对程序进行生逆，把密文逆成明文。。。也有队伍是这么做的，服：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162with open(&apos;Enigma&apos;, &apos;rb&apos;) as f: input_enc = list(f.read()[0x30a0:][:36])def bit(a, b): return (a &gt;&gt; b) &amp; 1# sub_11F0state = 0x5F3759DFfor i in range(9): v16 = bit(state, 0) ^ bit(state, 2) ^ bit(state, 3) ^ bit(state, 5) ^ bit(state, 7) ^ bit(state, 31) state = (state &gt;&gt; 1) | (v16 &lt;&lt; 31) for j in range(4): input_enc[i*4 + j] ^= (state &gt;&gt; (j*8)) &amp; 0xff# sub_F1Edef partialRev(c): c = bin(c)[2:].rjust(8, &apos;0&apos;) c = list(map(int, c)) r = list(reversed(c)) c = r[:3] + c[3:5] + r[5:] return int(&apos;&apos;.join(map(str, c)), 2)input_enc = list(map(partialRev, input_enc))# sub_124Fwire = [ [ 0x31, 0x62, 0x93, 0xC4 ], [ 0x21, 0x42, 0x63, 0x84 ], [ 0x3D, 0x7A, 0xB7, 0xF4 ], ]def _mix(a1, a2, a3): a5 = a3 ^ a2 ^ a1 a4 = a2 &amp; a1 | a3 &amp; (a2 | a1) return (a4, a5)def mix(a2, v16, a4): bits = [] for i in range(8): v4 = bit(a2, i) v5 = bit(v16, i) a4, a5 = _mix(v5, v4, a4) bits.insert(0, a5) return int(&apos;&apos;.join(map(str, bits)), 2), a4flag = []for i, t in enumerate(input_enc): for c in range(32, 128): a4 = 0 v16 = c a2 = wire[0][i%4] v16, a4 = mix(a2, v16, a4) a2 = wire[1][(i//4%4)] v16, a4 = mix(a2, v16, a4) a2 = wire[2][i//16] v16, a4 = mix(a2, v16, a4) if v16 == t: flag.append(c) breakprint(bytes(flag).decode(&apos;ascii&apos;)) 首先获取最后结果：1234with open(&apos;Enigma&apos;, &apos;rb&apos;) as f: input_enc = list(f.read()[0x30a0:][:36])print(input_enc) 然后得到sub_11F0异或之前的结果 该值是不是可以动态调试得到，内部有好多子函数，没有仔细分析123456state = 0x5F3759DFfor i in range(9): v16 = bit(state, 0) ^ bit(state, 2) ^ bit(state, 3) ^ bit(state, 5) ^ bit(state, 7) ^ bit(state, 31) state = (state &gt;&gt; 1) | (v16 &lt;&lt; 31) for j in range(4): input_enc[i*4 + j] ^= (state &gt;&gt; (j*8)) &amp; 0xff 然后是sub_F1E的逆向： 1234567def partialRev(c): c = bin(c)[2:].rjust(8, &apos;0&apos;) c = list(map(int, c)) r = list(reversed(c)) c = r[:3] + c[3:5] + r[5:] return int(&apos;&apos;.join(map(str, c)), 2)input_enc = list(map(partialRev, input_enc)) 也是看起来比较头疼的函数 最后是sub_124F，因为比较复杂，采用了正向python模拟实现然后爆破的方式： 没有勇气看下去。。。。12345678910111213141516171819wire = [ [ 0x31, 0x62, 0x93, 0xC4 ], [ 0x21, 0x42, 0x63, 0x84 ], [ 0x3D, 0x7A, 0xB7, 0xF4 ], ]def _mix(a1, a2, a3): a5 = a3 ^ a2 ^ a1 a4 = a2 &amp; a1 | a3 &amp; (a2 | a1) return (a4, a5)def mix(a2, v16, a4): bits = [] for i in range(8): v4 = bit(a2, i) v5 = bit(v16, i) a4, a5 = _mix(v5, v4, a4) bits.insert(0, a5) return int(&apos;&apos;.join(map(str, bits)), 2), a4","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://www.w4ter5heep.com/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.w4ter5heep.com/tags/CTF/"},{"name":"RE","slug":"RE","permalink":"http://www.w4ter5heep.com/tags/RE/"}]},{"title":"StarCTF-BabyDroid","slug":"StarCTF-BabyDroid","date":"2018-05-01T16:04:08.000Z","updated":"2018-05-01T16:30:24.660Z","comments":true,"path":"2018/05/02/StarCTF-BabyDroid/","link":"","permalink":"http://www.w4ter5heep.com/2018/05/02/StarCTF-BabyDroid/","excerpt":"","text":"逆向题目中唯一一道android逆向，做出来的过程也比较费力，这里简单记录。 安装程序发现会闪退，可能有反调试措施，首先进行静态分析。JEB查看Java代码部分： Alt text 关键方法是check0，同时注意到上面有许多check函数的native声明： Alt text 从so文件中查找相关方法。首先在liba.so中找到了check0函数：发现进一步调用的是check函数，但是在liba中没有相关信息，查找libb，没有直接找到check函数，考虑JNIOnLoad进行了注册，但是也没有找到JNIOnLoad函数，查找发现了sub_ED8函数： Alt text 对一部分数据进行了解密，同时发现了： Alt text Alt text 所以JNIOnLoad函数会在运行时才解密：解密的关键是这个值： Alt text 进入sub_9B4发现计算的应该是一个校验和，分析程序逻辑，写出计算校验和的脚本：1234567891011121314def crc32(ss): v2 = i32(-1) v7 = i32() for s in ss: if isinstance(s, bytes): s = s[0] for i in range(8): v7.value = v2.value ^ (s &gt;&gt; i &lt;&lt; 31) v2.value *= 2 if v7.value &lt;= -1: # if not 0x4C11DB7 &amp; 1: # v2.value ^= 1 v2.value ^= 0x4C11DB7 return u32(-v2.value).value - 1 得到libb的校验和：0x6674632a解密libb.so可以得到JNIOnLoad： Alt text 这里也进行了注册，将相关字符串进行解密可以发现就是对check函数的注册，解密脚本：1234567891011121314151617181920212223242526272829303132def xorstr(): def get_result(nums, key): nums = [[((i &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] for i in nums] # nums = sum(nums, []) nums = list(itertools.chain.from_iterable(nums)) nums = [i ^ key for i in itertools.takewhile(lambda i: i != 0, nums)] b = bytes(nums) return b nums = [0xBCFEFCF0, 0xEAE9A1E2, 0xF1F2F1BC, 0xF7FDF2EA, 0xF7FAFCE1, 0xFAF2DEBC, 0xE7F0D2FD, 0xE7FAE5FA, 0xea] print(get_result(nums, 0x93)) nums = [0x777C5A3E, 0x7A397760, 0x39717877, 0x7F646245, 0x3F2D7178, 0x4C] print(get_result(nums, 0x16)) nums = [0x73757873, 0x7B] print((get_result(nums, 0x10))) 解密结果为：com/q2zy/babyandroid/MainActivity (Ljava/lang/String;)Z check Alt text 即是注册的函数，但是发现依然是乱码，注意到下面还有一段解密： Alt text 这里用到了liba.so的校验和，计算发现也是0x6674632a解密得到check 函数： Alt text 再次用到了liba.so的校验和，分析逻辑写出解密脚本：1234567891011121314151617181920212223242526272829303132333435363738def get_flag(): crc = crc32(open(&apos;/Users/alset/Downloads/apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) crc2 = crc * crc checksums = [((crc2 &gt;&gt; (j * 8)) &amp; 0xff) for j in range(8)] b = bytearray([ 0xD5, 8, 0x4B, 0x11, 0xBF, 0xC, 0xB, 0x1F, 0xDC, 0x57, 0x64, 0x74, 0xB4, 0x6D, 0x5B, 0xD4, 0xEB, 0x1D, 0x51, 0xAE, 0xD5, 0x44, 8, # 0 ]) for i in range(8): for j in range(8): b[i + j] ^= checksums[j] i = 15 for j in range(8): b[i + j] ^= checksums[j] print(b) 得到flag：1nTr3stIng-AnDr0id-A&amp;D!完整解密脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import osimport mmapimport itertoolsfrom ctypes import c_int32 as i32, c_uint32 as u32def memory_map(filename, access=mmap.ACCESS_COPY): size = os.path.getsize(filename) fd = os.open(filename, os.O_RDWR) return mmap.mmap(fd, size, access=access)def crc32(ss): v2 = i32(-1) v7 = i32() for s in ss: if isinstance(s, bytes): s = s[0] for i in range(8): v7.value = v2.value ^ (s &gt;&gt; i &lt;&lt; 31) v2.value *= 2 if v7.value &lt;= -1: # if not 0x4C11DB7 &amp; 1: # v2.value ^= 1 v2.value ^= 0x4C11DB7 return u32(-v2.value).value - 1def recoverlibb(): m = memory_map(&apos;./apk/lib/armeabi-v7a/libb.so&apos;) start = 0xab8 size = 0x420 # right_asm = [0xf0, 0xb5, 0x3, 0xaf] # checksums = [m[start + i] ^ right_asm[i] for i in range(len(right_asm))] checksum = crc32(m) checksums = [((checksum &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] ichecksums = itertools.cycle(checksums) for i in range(size): m[start + i] = m[start + i] ^ next(ichecksums) start += 0x27C size -= 0x27C for i in range(0, , 4): m[start + i], m[start + i + 1], m[start + i + 2], m[start + i + 3] = m[start + i + 2], m[start + i + 3], m[ start + i], m[start + i + 1] # right_asm = [0xFF, 0xF7, 0x3E, 0xEE] # checksums = [m[start + size - 4 + i] ^ right_asm[i] for i in range(len(right_asm))] checksum = crc32(open(&apos;./apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) print(&apos;a: &apos;, checksum) checksums = [((checksum &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] ichecksums = itertools.cycle(checksums) for i in range(size): m[start + i] = m[start + i] ^ next(ichecksums) m.seek(0) open(&apos;./apk/lib/armeabi-v7a/libbnew2.so&apos;, &apos;wb&apos;).write(m.read())def xorstr(): def get_result(nums, key): nums = [[((i &gt;&gt; (j * 8)) &amp; 0xff) for j in range(4)] for i in nums] # nums = sum(nums, []) nums = list(itertools.chain.from_iterable(nums)) nums = [i ^ key for i in itertools.takewhile(lambda i: i != 0, nums)] b = bytes(nums) return b nums = [0xBCFEFCF0, 0xEAE9A1E2, 0xF1F2F1BC, 0xF7FDF2EA, 0xF7FAFCE1, 0xFAF2DEBC, 0xE7F0D2FD, 0xE7FAE5FA, 0xea] print(get_result(nums, 0x93)) nums = [0x777C5A3E, 0x7A397760, 0x39717877, 0x7F646245, 0x3F2D7178, 0x4C] print(get_result(nums, 0x16)) nums = [0x73757873, 0x7B] print((get_result(nums, 0x10)))def get_flag(): crc = crc32(open(&apos;./apk/lib/armeabi-v7a/liba.so&apos;, &apos;rb&apos;).read()) crc2 = crc * crc checksums = [((crc2 &gt;&gt; (j * 8)) &amp; 0xff) for j in range(8)] b = bytearray([ 0xD5, 8, 0x4B, 0x11, 0xBF, 0xC, 0xB, 0x1F, 0xDC, 0x57, 0x64, 0x74, 0xB4, 0x6D, 0x5B, 0xD4, 0xEB, 0x1D, 0x51, 0xAE, 0xD5, 0x44, 8, # 0 ]) for i in range(8): for j in range(8): b[i + j] ^= checksums[j] i = 15 for j in range(8): b[i + j] ^= checksums[j] print(b)if __name__ == &apos;__main__&apos;: # xorstr() # recoverlibb() get_flag()","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://www.w4ter5heep.com/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.w4ter5heep.com/tags/CTF/"},{"name":"Mobile","slug":"Mobile","permalink":"http://www.w4ter5heep.com/tags/Mobile/"}]},{"title":"HITB2018线上赛——Mobile","slug":"HITB2018线上赛——Mobile","date":"2018-04-15T15:16:39.000Z","updated":"2018-06-04T13:14:37.932Z","comments":true,"path":"2018/04/15/HITB2018线上赛——Mobile/","link":"","permalink":"http://www.w4ter5heep.com/2018/04/15/HITB2018线上赛——Mobile/","excerpt":"","text":"最近参加了HITB2018，主要做了两道Mobile，简单整理题目。 multicheck题目提示:Check！Check！Check！大概是有陷阱。 安装apk，没有多余的提示，输入flag，进行验证。首先jeb分析下java部分： 方法通过就可以了。首先看到了上面： 似乎加载了一个方法。解压apk包，找到assets中的claz.dex，赶快用jeb打开： 好像有flag，赶快手动排序得到了假的flag，提示大概是this is certainly not the flag，确实是坑。 只能继续分析so文件libcheck.soJNI_OnLoad也没有有用信息，只能挨个看sub函数找到sub_1380 注意这一段，好像进行了解密和文件的替换，byte_4004^v9并赋值到v8即是对claz.dex文件的替换。将byte_4004部分数据dump出来进行解密。保存为.dex，会发现是可以被解析的。可能就是真正的check。 这部分的调用还是稍微有些复杂的，分析了半天本来想爆破的，但是注意到了一个特殊值，即：v5 = -1640531527，查看16进制：0x9E3779B9搜索发现是Tea加密的特征值。直接从网上找可用的Tea加解密程序。过程十分曲折，找到的一些版本的程序，但是加解密结果各不相同，有点崩溃。。。终于找到一个较为标准的Java版，得到了结果。编程水平太差，只能复制粘贴，惭愧。 脚本如下：生成.dex的脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127a = [0x8D,0x8F,0x93,0xE6,0xDD,0xDD,0xDA,0xF0,0x74,0xF2,0x03,0x6D,0xC0,0xD3,0x07,0x29,0x9A,0x97,0xB7,0x3D,0xD6,0x0B,0xBC,0x53,0xF4,0x89,0x8E,0x08,0x21,0x52,0xE9,0x42,0x35,0x0D,0x0B,0x0C,0x7D,0x0E,0x0F,0x10,0x69,0x44,0x27,0x06,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x81,0x18,0x1F,0x20,0x3D,0x22,0x23,0x24,0x55,0x26,0x27,0x28,0x22,0x2A,0x2B,0x2C,0xCD,0x2E,0x2F,0x30,0x3B,0x32,0x33,0x34,0x39,0x37,0x37,0x38,0x3B,0x3A,0x3B,0x3C,0xB9,0x3F,0x3F,0x40,0x4D,0x42,0x43,0x44,0xD1,0x47,0x47,0x48,0x48,0x4A,0x4B,0x4C,0xB9,0x4F,0x4F,0x50,0x79,0x57,0x53,0x54,0x41,0x54,0x57,0x58,0x75,0x5F,0x5B,0x5C,0x6B,0x5B,0x5F,0x60,0x5F,0x67,0x63,0x64,0x24,0x63,0x67,0x68,0x24,0x6F,0x6B,0x6C,0x3D,0x6B,0x6F,0x70,0x25,0x77,0x73,0x74,0x22,0x73,0x77,0x78,0x22,0x7F,0x7B,0x7C,0x1D,0x7B,0x7F,0x80,0xE6,0x87,0x83,0x84,0xF3,0x83,0x87,0x88,0x03,0x8F,0x8B,0x8C,0x13,0x8B,0x8F,0x90,0x23,0x97,0x93,0x94,0x53,0x93,0x97,0x98,0x50,0x9F,0x9B,0x9C,0x4C,0x9B,0x9F,0xA0,0x75,0xA7,0xA3,0xA4,0x7D,0xA3,0xA7,0xA8,0x74,0xAF,0xAB,0xAC,0x4C,0xAB,0xAF,0xB0,0x54,0xB7,0xB3,0xB4,0x5D,0xB3,0xB7,0xB8,0x4A,0xBF,0xBB,0xBC,0x4B,0xBB,0xBF,0xC0,0x3C,0xC7,0xC3,0xC4,0xC0,0xC0,0xC7,0xC8,0xCB,0xCA,0xCB,0xCC,0xC9,0xCE,0xCF,0xD0,0xDB,0xD2,0xD3,0xD4,0xDE,0xD6,0xD7,0xD8,0xD5,0xDA,0xDB,0xDC,0xD0,0xDE,0xDF,0xE0,0xEF,0xE2,0xE3,0xE4,0xEA,0xE6,0xE7,0xE8,0xF8,0xEA,0xEB,0xEC,0xF9,0xEE,0xEF,0xF0,0xE4,0xF2,0xF3,0xF4,0xF0,0xF6,0xF7,0xF8,0xF8,0xFA,0xFB,0xFC,0x1D,0xFA,0xFF,0x00,0x0E,0x02,0x03,0x04,0x02,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x1D,0x0E,0x0F,0x10,0x16,0x12,0x13,0x14,0xFD,0x12,0x17,0x18,0x0B,0x1A,0x1B,0x1C,0x15,0x1E,0x1F,0x20,0xD9,0x26,0x23,0x24,0x36,0x26,0x27,0x28,0x21,0x2A,0x2B,0x2C,0x2D,0x2B,0x2F,0x30,0x37,0x32,0x33,0x34,0x3C,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3A,0x3E,0x3F,0x40,0x48,0x42,0x43,0x44,0x4D,0x43,0x47,0x48,0x40,0x4A,0x4B,0x4C,0x44,0x4E,0x4F,0x50,0x41,0x57,0x53,0x54,0x5D,0x56,0x57,0x58,0x50,0x5A,0x5B,0x5C,0x41,0x5B,0x5F,0x60,0x69,0x62,0x63,0x64,0x6F,0x66,0x67,0x68,0x4D,0x6F,0x6B,0x6C,0x6F,0x6E,0x65,0x70,0x67,0x72,0x73,0x74,0x77,0x76,0x7E,0x78,0x61,0x7A,0x7B,0x7C,0x7F,0x7E,0x7E,0x80,0x81,0x82,0x83,0x84,0x87,0x86,0x86,0x88,0x88,0x8A,0x8B,0x8C,0x8F,0x8E,0x8F,0x90,0x87,0x92,0x93,0x94,0x97,0x96,0x91,0x98,0x8F,0x9A,0x9B,0x9C,0x9F,0x9E,0x98,0xA0,0xB7,0xA2,0xA3,0xA4,0xA7,0xA6,0xAF,0xA8,0xBF,0xAA,0xAB,0xAC,0xAF,0xAE,0xA6,0xB0,0xA7,0xB2,0xB3,0xB4,0xB7,0xB6,0xB4,0xB8,0xA0,0xBA,0xBB,0xBC,0xBE,0xBE,0xBE,0xC0,0xC0,0xC2,0xC3,0xC4,0xC1,0xC6,0xC2,0xC8,0xD2,0xCA,0xCB,0xCC,0xC8,0xCE,0xCD,0xD0,0xC6,0xD2,0xD3,0xD4,0xD3,0xD6,0xD3,0xD8,0xC3,0xDA,0xDB,0xDC,0xDF,0xDE,0xDF,0xE0,0xE0,0xE2,0xE3,0xE4,0xE6,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xEE,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0x85,0xF0,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFC,0xFE,0xFF,0x00,0x01,0x02,0x03,0x04,0x0A,0x00,0x07,0x08,0x3B,0x0A,0x0B,0x0C,0x1F,0x4E,0x2C,0x10,0x1B,0x12,0x35,0x14,0x1A,0x16,0x17,0x18,0x70,0x1A,0x1B,0x1C,0x0E,0x1E,0x3F,0x20,0x02,0x22,0x2A,0x24,0x03,0x26,0x35,0x28,0x29,0x2A,0x42,0x2C,0x2C,0x2E,0x21,0x30,0x31,0x31,0x37,0x34,0x31,0x36,0x37,0x38,0x92,0x91,0x90,0x97,0xF0,0xF3,0xF2,0x8D,0xAE,0xAD,0xAC,0xAB,0x3D,0x10,0x73,0x5A,0x49,0x49,0x4A,0x4C,0x6D,0x4E,0x4F,0x50,0x32,0x2E,0x36,0xBD,0xDB,0x07,0x86,0x81,0xC3,0x15,0x4D,0x68,0x84,0xFC,0xE1,0xD8,0x04,0x8C,0x2A,0x81,0x50,0x9D,0x49,0x84,0x08,0x61,0xA3,0x48,0x80,0xA1,0xFF,0xC5,0x70,0x72,0x72,0x74,0x74,0x76,0x77,0x78,0x64,0x7C,0x7B,0x7C,0x79,0x7E,0x7F,0x80,0xF1,0x92,0x8B,0x84,0x85,0x86,0x89,0x88,0x88,0x8A,0x8A,0x8C,0x8D,0x8E,0x8F,0x90,0xB3,0x94,0x93,0x94,0x90,0x96,0x97,0x98,0xA2,0x9A,0x9F,0x9C,0x4D,0x9E,0x9F,0xA1,0xAE,0xA2,0xA3,0xA4,0xA2,0xA6,0xA6,0xA8,0xAC,0xAA,0xAB,0xAC,0x86,0xA8,0xAF,0xB0,0x98,0xB2,0xB3,0xB4,0xA7,0xB7,0x96,0xD8,0x65,0xBA,0xBB,0xB4,0x64,0xBE,0xBF,0xC8,0xE0,0xA0,0x73,0xC6,0xE6,0xE4,0xCE,0xC8,0x44,0xC9,0x84,0xCF,0xCF,0xCF,0xEE,0xB3,0xA0,0x81,0xD9,0xD4,0xC3,0xD4,0xF6,0xF8,0xFA,0xD9,0xD2,0xDC,0xDC,0xCE,0xFE,0xD4,0xD4,0xA2,0xF1,0xE4,0x87,0xE2,0xE7,0xE8,0xFA,0xEF,0xCB,0xEC,0x9C,0xAE,0xEB,0xF0,0xF3,0xA6,0xFF,0xF0,0xE6,0xF3,0xFF,0xF8,0x88,0xAF,0xF1,0xFC,0xE9,0xFD,0x27,0x00,0x01,0x0A,0x2B,0xEA,0x14,0x05,0x07,0x08,0x19,0x0A,0x0F,0x0C,0x0F,0x0E,0x0F,0x10,0x2B,0x14,0x13,0x14,0x56,0x16,0x17,0x18,0x68,0x3A,0x1D,0x1C,0xC1,0x1E,0x13,0x24,0x33,0x22,0x67,0x27,0x21,0x26,0x35,0x38,0x6D,0x28,0x2F,0x2C,0x3F,0x2F,0x3B,0x35,0x88,0x4B,0x04,0xAA,0x27,0x36,0x73,0x3E,0x37,0x3A,0x29,0x2C,0x79,0x39,0x31,0x40,0x53,0x62,0x07,0x4C,0x4B,0x46,0x55,0x78,0x0D,0x43,0x45,0x4C,0x5F,0x4E,0x7A,0xA0,0x4D,0x52,0xE3,0x05,0xB5,0x5C,0x55,0x5C,0xE9,0x30,0xCB,0x57,0x5F,0x5F,0xE8,0xDA,0x80,0x69,0x61,0x61,0xD5,0x1D,0xD0,0xD2,0xD9,0xC9,0x8B,0x66,0x6E,0x6A,0xDF,0xFA,0xE1,0x79,0x70,0x75,0xC2,0xCC,0x96,0x73,0x7A,0x7F,0xCB,0xE7,0xCA,0xC4,0xCF,0x22,0x59,0x82,0x83,0x85,0xAD,0x63,0x95,0x88,0xC2,0x89,0x8F,0x8C,0x9F,0x9E,0xC4,0x92,0x95,0x92,0x81,0x94,0xE4,0xB6,0x92,0x98,0x9D,0x9A,0x97,0x9C,0x8C,0x9E,0x9F,0xA0,0xA7,0xA2,0xA1,0xA4,0xA5,0xA6,0xA7,0xA8,0xE7,0xAC,0xAB,0xAC,0x9A,0xAE,0xAF,0xB0,0x90,0xF2,0x53,0xB4,0xB5,0xB4,0x94,0xB9,0xB0,0xBA,0xA9,0xBC,0x9C,0xAC,0x8A,0xE5,0xEE,0xC2,0x1B,0xC6,0xC0,0xC5,0x83,0xCB,0xCD,0xCA,0x1E,0xFF,0x32,0xCE,0x42,0xE3,0x9E,0xD1,0xD2,0xD6,0x0D,0xD4,0xD2,0xDA,0x9D,0xD9,0xDF,0xDC,0x3C,0xDD,0xDC,0xE8,0x34,0xD1,0x1C,0xE4,0x68,0xD5,0xA8,0xEB,0xE8,0xE8,0x33,0xEE,0xE8,0xEF,0xAB,0xF3,0xF5,0xF2,0x12,0xF7,0xF6,0xE6,0x22,0xCB,0x06,0xFA,0x76,0xCF,0xB2,0xFD,0xFE,0x02,0x45,0x00,0x07,0x04,0xE4,0x04,0x05,0x10,0xDC,0x28,0xF4,0x0C,0x80,0x2C,0x40,0x12,0x10,0x17,0xCB,0x14,0x15,0x17,0xCF,0x1D,0x1C,0x1E,0x33,0xCD,0x0C,0x1F,0x1F,0x20,0x27,0x22,0x21,0x24,0x24,0x26,0x27,0x28,0x75,0x2C,0x2B,0x2C,0x19,0x2E,0x2F,0x30,0x10,0x72,0xD2,0x34,0x35,0x34,0x14,0x39,0x33,0x3A,0x29,0x3C,0x1C,0x7C,0x0A,0x65,0x6D,0x42,0x9B,0x46,0x40,0x45,0x0F,0x4A,0x4D,0x48,0x3A,0x5C,0x4F,0x4E,0x4D,0x50,0x5B,0x50,0x8B,0x57,0x50,0x54,0x1F,0x5B,0x5D,0x59,0x2A,0x4C,0x5F,0x5E,0x5C,0x60,0x6B,0x61,0x83,0x67,0x66,0x6E,0xD1,0x5A,0xB1,0x69,0x6E,0x6D,0x25,0x6D,0x6B,0x73,0x00,0x62,0x71,0x74,0x76,0x76,0x7D,0x7B,0x99,0x79,0x78,0x6C,0xCB,0x4C,0x37,0x83,0x85,0x87,0x63,0x87,0x86,0x9E,0x31,0xBA,0xC2,0x88,0x8A,0x8C,0x55,0x8E,0x8F,0x91,0x49,0x97,0x96,0x90,0xBD,0x42,0x86,0x99,0x9A,0x9A,0x9A,0x9C,0x9F,0x9E,0x9F,0xA0,0xCB,0xA4,0xA3,0xA4,0xAA,0xA6,0xA7,0xA8,0xC7,0xBA,0xA2,0xAC,0xAF,0xAE,0xA3,0xB0,0xC0,0xA2,0xB0,0xB4,0xB5,0xB6,0xBB,0xB8,0xDB,0xBB,0xBA,0xBC,0xCC,0x9E,0xB4,0xC0,0xD1,0xC2,0xC9,0xC4,0xCA,0xC6,0xC7,0xC8,0xC8,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD4,0xD2,0xD3,0xD4,0xD6,0xD6,0xD6,0xD8,0xDA,0xDA,0xDA,0xDC,0xDC,0xDE,0xDF,0xE0,0xE0,0xE2,0xE3,0xE4,0xE1,0xE6,0xE7,0xE8,0xEB,0xEA,0xEB,0xEC,0xE4,0xEE,0xE6,0xF0,0xF0,0xF2,0xF3,0xF4,0xFC,0xF6,0xF7,0xF8,0xFD,0xFA,0xFB,0xFC,0xF4,0xFE,0xFE,0x00,0x0B,0x02,0x02,0x04,0x07,0x06,0x07,0x08,0x03,0x0A,0x0A,0x0C,0x0F,0x0E,0x0F,0x10,0x18,0x12,0x12,0x14,0x1D,0x2A,0x74,0x74,0x70,0x74,0x72,0x68,0x23,0x1E,0x19,0x1C,0x48,0x4C,0x4A,0x50,0x1B,0x26,0x26,0x6A,0x29,0x20,0x68,0x44,0x48,0x4D,0x44,0x1E,0x5B,0x53,0x45,0x55,0x35,0x37,0x7E,0x38,0x3B,0x73,0x79,0x3C,0x3C,0x72,0x3F,0x42,0x0D,0x0E,0x43,0x47,0x09,0x0A,0x0E,0x48,0x4C,0x06,0x07,0x05,0x01,0x07,0x4F,0x5D,0x1D,0x31,0x3C,0x39,0x7A,0x37,0x78,0x1B,0x31,0x3F,0x38,0x37,0x66,0x5E,0x4D,0x2C,0x0B,0x03,0x15,0x05,0x4A,0x0A,0x06,0x06,0x0E,0x45,0x24,0x0E,0x07,0x0B,0x0C,0x04,0x4A,0x72,0x61,0x38,0x1F,0x17,0x01,0x19,0x56,0x16,0x1A,0x12,0x1A,0x51,0x2C,0xF4,0xF3,0xEB,0xED,0xE3,0xBE,0x86,0x95,0xC4,0xE3,0xEB,0xFD,0xED,0xA2,0xE2,0xEE,0xFE,0xF6,0xBD,0xC0,0xED,0xE6,0xE2,0xF2,0xF5,0xA2,0x9A,0x89,0xD0,0xF7,0xFF,0xE9,0xC1,0x8E,0xD7,0xD7,0xCD,0xC9,0x89,0xE6,0xDA,0xDB,0xCB,0xD2,0xDF,0x96,0xAE,0xAE,0xE6,0xB1,0xB4,0xE5,0xF8,0xFC,0xFA,0xFE,0xF1,0xB9,0xBB,0xE1,0xBC,0xBF,0xE4,0xF3,0xC0,0xC2,0x98,0x8F,0x88,0xC5,0xC4,0x9C,0x8A,0xC9,0xC8,0x90,0x85,0xCD,0xCF,0xAE,0xD0,0xD8,0xB3,0xA1,0xA6,0xB4,0xAF,0xB4,0xB7,0xA9,0xA3,0xDB,0xDD,0xBF,0xDE,0xDA,0x83,0x89,0x87,0x80,0x8F,0xE5,0xE0,0x82,0x99,0x9C,0x8B,0x87,0x9F,0xED,0xE6,0x88,0x95,0x85,0xB0,0x8A,0x80,0x90,0x85,0xF7,0xC4,0xF9,0xFD,0xF5,0xFE,0xE8,0x78,0xFD,0x6B,0xA5,0x00,0x16,0xC6,0x05,0x03,0x07,0x0F,0x07,0x0A,0x38,0x0D,0x0D,0x09,0x01,0x1F,0x3C,0x3C,0x13,0x50,0x14,0x16,0x10,0x05,0x43,0x51,0x27,0x57,0x56,0x22,0x98,0x77,0x1E,0x22,0x2B,0x20,0x25,0x26,0x27,0x28,0x2E,0x24,0x60,0x54,0x11,0xEA,0x12,0x2E,0x85,0x9D,0x72,0x08,0x09,0x36,0x10,0x3A,0x39,0x3A,0x3C,0x32,0x67,0x75,0xA9,0xF4,0xF5,0xD3,0x1C,0x44,0x59,0x44,0x47,0x48,0x4E,0x44,0x11,0x07,0x4C,0x59,0x40,0x8E,0x0C,0x52,0x07,0x55,0x55,0x51,0x59,0x58,0x5B,0x5A,0x53,0x5C,0x5D,0x54,0x5E,0x6A,0x61,0xEA,0xE3,0x60,0xF1,0x62,0x66,0xE9,0xE9,0x6E,0xE3,0x69,0x6C,0x64,0xCF,0x75,0x70,0x7B,0xCF,0x71,0x74,0x7E,0xD7,0x7E,0x78,0x70,0xC3,0x7B,0x7C,0x74,0xC7,0x88,0x80,0x8B,0x33,0x8D,0x88,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8C,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x94,0x96,0x97,0x98,0x85,0x9A,0x9B,0x9C,0xED,0x9E,0x9F,0xA0,0xA3,0xA2,0xA3,0xA4,0xAE,0xA6,0xA7,0xA8,0x49,0xAA,0xAB,0xAC,0xAE,0xAE,0xAF,0xB0,0xBB,0xB2,0xB3,0xB4,0xB9,0xB7,0xB7,0xB8,0xBD,0xBA,0xBB,0xBC,0xBF,0xBE,0xBF,0xC0,0x45,0xC3,0xC3,0xC4,0xC0,0xC6,0xC7,0xC8,0xC5,0xCA,0xCB,0xCC,0x59,0xCF,0xCF,0xD0,0xD7,0xD2,0xD3,0xD4,0xD4,0xD6,0xD7,0xD8,0x2D,0xDB,0xDB,0xDC,0xDC,0xFE,0xDF,0xE0,0xE9,0xE2,0xE3,0xE4,0xF1,0xE4,0xE7,0xE8,0xE8,0xFA,0xEB,0xEC,0xE5,0xEE,0xEF,0xF0,0x11,0xF6,0xF3,0xF4,0xF7,0xD6,0xF7,0xF8,0xE5,0xFA,0xFB,0xFC,0xD1,0xFB,0xFF,0x00,0x02,0x22,0x03,0x04,0x0D,0x06,0x07,0x08,0x06,0x0C,0x0B,0x0C,0x0D,0x2E,0x0F,0x10,0x10,0x12,0x13,0x14,0x65,0x10,0x17,0x18,0x19,0x0A,0x1B,0x1C,0x1C,0x1E,0x1F,0x20,0xBD,0x24,0x23,0x24]v9 = 233out = &quot;&quot;for i in range(0x73c): tmp = (a[i]^v9)&amp;0xFF out += chr(tmp) v9 += 1fp = open(&quot;claz2.dex&quot;, &quot;wb&quot;)fp.write(out)fp.close() Tea的加解密程序：该java版本还是较为标准的实现，可以收藏。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package hitb2018;public class Tea &#123; private final static int[] KEY = new int[]&#123;//加密解密所用的KEY 0xABABABAB, 0xCDCDCDCD, 0xEFEFEFEF, 0x12345678 &#125;; //加密 public static byte[] encrypt(byte[] content, int offset, int[] key, int times)&#123;//times为加密轮数 int[] tempInt = byteToInt(content, offset); int y = tempInt[0], z = tempInt[1], sum = 0, i; int delta=0x9e3779b9; //这是算法标准给的值 int a = key[0], b = key[1], c = key[2], d = key[3]; for (i = 0; i &lt; times; i++) &#123; sum += delta; y += ((z&lt;&lt;4) + a) ^ (z + sum) ^ ((z&gt;&gt;5) + b); z += ((y&lt;&lt;4) + c) ^ (y + sum) ^ ((y&gt;&gt;5) + d); &#125; tempInt[0]=y; tempInt[1]=z; return intToByte(tempInt, 0); &#125; //解密 public static byte[] decrypt(byte[] encryptContent, int offset, int[] key, int times)&#123; int[] tempInt = byteToInt(encryptContent, offset); int y = tempInt[0], z = tempInt[1], sum = 0, i; int delta=0x9e3779b9; //这是算法标准给的值 int a = key[0], b = key[1], c = key[2], d = key[3]; if (times == 32) sum = 0xC6EF3720; /* delta &lt;&lt; 5*/ else if (times == 16) sum = 0xE3779B90; /* delta &lt;&lt; 4*/ else sum = delta * times; for(i = 0; i &lt; times; i++) &#123; z -= ((y&lt;&lt;4) + c) ^ (y + sum) ^ ((y&gt;&gt;5) + d); y -= ((z&lt;&lt;4) + a) ^ (z + sum) ^ ((z&gt;&gt;5) + b); sum -= delta; &#125; tempInt[0] = y; tempInt[1] = z; return intToByte(tempInt, 0); &#125; //byte[]型数据转成int[]型数据 private static int[] byteToInt(byte[] content, int offset)&#123; int[] result = new int[content.length &gt;&gt; 2];//除以2的n次方 == 右移n位 即 content.length / 4 == content.length &gt;&gt; 2 for(int i = 0, j = offset; j &lt; content.length; i++, j += 4)&#123; result[i] = transform(content[j + 3]) | transform(content[j + 2]) &lt;&lt; 8 | transform(content[j + 1]) &lt;&lt; 16 | (int)content[j] &lt;&lt; 24; &#125; return result; &#125; //int[]型数据转成byte[]型数据 private static byte[] intToByte(int[] content, int offset)&#123; byte[] result = new byte[content.length &lt;&lt; 2];//乘以2的n次方 == 左移n位 即 content.length * 4 == content.length &lt;&lt; 2 for(int i = 0, j = offset; j &lt; result.length; i++, j += 4)&#123; result[j + 3] = (byte)(content[i] &amp; 0xff); result[j + 2] = (byte)((content[i] &gt;&gt; 8) &amp; 0xff); result[j + 1] = (byte)((content[i] &gt;&gt; 16) &amp; 0xff); result[j] = (byte)((content[i] &gt;&gt; 24) &amp; 0xff); &#125; return result; &#125; //若某字节为负数则需将其转成无符号正数 private static int transform(byte temp)&#123; int tempInt = (int)temp; if(tempInt &lt; 0)&#123; tempInt += 256; &#125; return tempInt; &#125; public static void main(String[] args)&#123; byte[] enContent = new byte[]&#123;99, 124, 101, -23, -114, 81, -47, -39, -102, 79, 22, 52, -39, -94, -66, -72, 101, -18, 73, -27, 53, -5, 46, -20, 97, 11, -56, 36, -19, -49, -112, -75&#125;; for(int j=0;j&lt;4;j++)&#123; byte[] deContent = decrypt(enContent,j*8,KEY,32); for(int i = 0;i &lt; 8;i++)&#123; System.out.print((char)deContent[i]); &#125; &#125; &#125;&#125; 其实对整个程序的动态加载和替换过程还不是很了解。题目有点小坑，但是还能接受。HITB{SEe!N9_IsN’T_bELIEV1Ng} kivy simpleapk包有点大，但是安装以后也没有特别的功能。首先搜索kivy，kivy是使用python进行全平台应用开发的框架，该apk也是使用该python框架进行开发的，通过JEB对java代码以及IDA对so文件的分析，并没有发现程序的主逻辑。进一步，通过学习kivy框架的开发以及程序打包流程，同时注意到了解压缩后在assets中的private.mp3文件，猜测为压缩包。 修改文件名后缀，解压得到部分文件(这里注意，在不同平台下可能要解压两次，比如windows下) 找到了python 编写的主函数等文件使用uncompyle6对main.pyo得到main.py：其中有一段：123456789101112def check(self): if self.flag.text == &apos;HITB&#123;this_is_not_flag&#125;&apos;: return True return Falsedef auth(self, instance): if self.check(): s = &apos;Congratulations you got the flag&apos; else: s = &apos;Wrong answer&apos; popup = Popup(title=&apos;result&apos;, content=Label(text=s), auto_dismiss=True) popup.open() 逻辑很简单，但HITB{this_is_not_flag}不是答案，还是骗人的。注意到：12b64 = &apos;eJzF1MtOE2EUB/DzTculUKAUKJSr3OqIV0TBGEOMRqIuatJhowsndTrVA+MlnYEYhZXEhQuXLlz4CC58BBc+ggsfwYWPYDznhHN8BJr5Tv7fby6Z8/VrIzj+eDRu0kirVFoARwCPAGI6HOx4EBI6CHy+LHLH1/O4zfd8onQAsEOHg0MHmQcHDt45vmc3B50FyHIQELU8qLZyYutmebIusftm3WQ9Yo/NeskKYh2zPrJ+sfdmRbIBsc9mg2RDYl/NSmTDYt/NymQjYj/NRsnGxH6bVcjGxf6aTZBVxcpObdL6rZlNkU2LXTebsT7qZrP2fk/M5shOie2bzdvzPpgtkC2KfTFbIlsW+2ZWIzst9sPMJzsj9stsheys2B+zc2TnxTxP7YL1UTG7aLZidolsVWzT7LL11jBbI7si1ja7SrYu9sZsw+yjWJaHgHZx4F+j/VnHOao4TCXjvbuBQxqXsV9jgDmNt7CiMURP4zZOaXyA3RrncVTjEpY0djCv8S2Oa3yF/OtC0PldLPN8hkuf4ioO8nxA5zWc1LiITuM97NG4hbMaD3FE4z4W+TEFLhOKD7GL59M6r+OYxjXsperz+YzfvZ00n0rI4tdZxkuTxC8yPr3VTNJYTm139mL5S5BZGidteVTqc4dSMil8V/Qsjnb52vSIzRVdGfKu5E5seHWfu2rw3sj460yjTkwt8oqFYZQ00zQM/3cipSErzQt14/nL1l4Sb0pHXAp3/gENPMQt&apos;eval(marshal.loads(zlib.decompress(binascii.a2b_base64(b64)))) 说明程序可能进行了动态的加载和替换。将zlib.decompress(binascii.a2b_base64(b64))后的内容实际上是PythonCodeObject对象，通过查找资料，可以将该对象转化为.pyc文件，进而反编译。转换代码：123456789101112131415161718192021import py_compileimport impimport osimport binasciiimport zlibimport marshaldef pycodeobject2pyc(pyobj, pycfile): with open(pycfile, &apos;wb&apos;) as fc: fc.write(&apos;\\0\\0\\0\\0&apos;) timestamp = long(os.fstat(fc.fileno()).st_mtime) py_compile.wr_long(fc, timestamp) marshal.dump(pyobj, fc) fc.flush() fc.seek(0, 0) MAGIC = imp.get_magic() fc.write(MAGIC)if __name__ == &quot;__main__&quot;: b64 = &apos;eJzF1MtOE2EUB/DzTculUKAUKJSr3OqIV0TBGEOMRqIuatJhowsndTrVA+MlnYEYhZXEhQuXLlz4CC58BBc+ggsfwYWPYDznhHN8BJr5Tv7fby6Z8/VrIzj+eDRu0kirVFoARwCPAGI6HOx4EBI6CHy+LHLH1/O4zfd8onQAsEOHg0MHmQcHDt45vmc3B50FyHIQELU8qLZyYutmebIusftm3WQ9Yo/NeskKYh2zPrJ+sfdmRbIBsc9mg2RDYl/NSmTDYt/NymQjYj/NRsnGxH6bVcjGxf6aTZBVxcpObdL6rZlNkU2LXTebsT7qZrP2fk/M5shOie2bzdvzPpgtkC2KfTFbIlsW+2ZWIzst9sPMJzsj9stsheys2B+zc2TnxTxP7YL1UTG7aLZidolsVWzT7LL11jBbI7si1ja7SrYu9sZsw+yjWJaHgHZx4F+j/VnHOao4TCXjvbuBQxqXsV9jgDmNt7CiMURP4zZOaXyA3RrncVTjEpY0djCv8S2Oa3yF/OtC0PldLPN8hkuf4ioO8nxA5zWc1LiITuM97NG4hbMaD3FE4z4W+TEFLhOKD7GL59M6r+OYxjXsperz+YzfvZ00n0rI4tdZxkuTxC8yPr3VTNJYTm139mL5S5BZGidteVTqc4dSMil8V/Qsjnb52vSIzRVdGfKu5E5seHWfu2rw3sj460yjTkwt8oqFYZQ00zQM/3cipSErzQt14/nL1l4Sb0pHXAp3/gENPMQt&apos; data = marshal.loads(zlib.decompress(binascii.a2b_base64(b64))) pycodeobject2pyc(data, &quot;apk2.pyc&quot;) 该段代码参考了https://segmentfault.com/q/1010000003052356 PythonCodeObject转换为.pyc也费了一番功夫，基础不扎实，不知道该怎么处理。太菜了。再次用uncompyle6进行反编译得到真正的check代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970def check(self): s = self.flag.text if len(s) != 31: return False if s[17] != &apos;7&apos;: return False if s[15] != &apos;%&apos;: return False if s[11] != &apos;S&apos;: return False if s[3] != &apos;B&apos;: return False if s[22] != &apos;_&apos;: return False if s[2] != &apos;T&apos;: return False if s[27] != &apos;O&apos;: return False if s[6] != &apos;!&apos;: return False if s[20] != &apos;$&apos;: return False if s[16] != &apos;r&apos;: return False if s[4] != &apos;&#123;&apos;: return False if s[23] != &apos;p&apos;: return False if s[25] != &apos;7&apos;: return False if s[0] != &apos;H&apos;: return False if s[18] != &apos;_&apos;: return False if s[29] != &apos;!&apos;: return False if s[10] != &apos;1&apos;: return False if s[14] != &apos;H&apos;: return False if s[13] != &apos;&amp;&apos;: return False if s[26] != &apos;#&apos;: return False if s[1] != &apos;I&apos;: return False if s[7] != &apos;F&apos;: return False if s[30] != &apos;&#125;&apos;: return False if s[19] != &apos;v&apos;: return False if s[12] != &apos;_&apos;: return False if s[9] != &apos;_&apos;: return False if s[24] != &apos;Y&apos;: return False if s[5] != &apos;1&apos;: return False if s[28] != &apos;N&apos;: return False if s[21] != &apos;3&apos;: return False if s[8] != &apos;3&apos;: return False return Truescreen.__class__.check = check! 此处才是真正进行逻辑判断的函数手动排序得到flag：HITB{1!F3_1S_&amp;H%r7_v$3_pY7#ON!}","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://www.w4ter5heep.com/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.w4ter5heep.com/tags/CTF/"},{"name":"Mobile","slug":"Mobile","permalink":"http://www.w4ter5heep.com/tags/Mobile/"}]},{"title":"hellow_my_site","slug":"hellow-my-site","date":"2018-04-05T09:19:55.000Z","updated":"2018-04-15T15:24:44.871Z","comments":true,"path":"2018/04/05/hellow-my-site/","link":"","permalink":"http://www.w4ter5heep.com/2018/04/05/hellow-my-site/","excerpt":"","text":"can you see my secret","categories":[{"name":"Welcome!","slug":"Welcome","permalink":"http://www.w4ter5heep.com/categories/Welcome/"}],"tags":[{"name":"MySite","slug":"MySite","permalink":"http://www.w4ter5heep.com/tags/MySite/"}]}]}